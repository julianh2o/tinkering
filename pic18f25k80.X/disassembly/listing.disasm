Disassembly Listing for pic18f25k80
Generated From:
/home/julian/Hobby/Development/tinkering/julianh2_tinkering/pic18f25k80.X/dist/default/production/pic18f25k80.X.production.cof
Dec 7, 2013 5:00:02 PM

---  /home/julian/Hobby/Development/tinkering/julianh2_tinkering/pic18f25k80.X/serlcd.c  ----------------
1:             #include "serlcd.h"
2:             
3:             char charactersSinceFill = 0;
4:             
5:             void setupLCD(void) {
6:                 TRISCbits.TRISC6 = 1;
0884  8C94     BSF TRISC, 6, ACCESS
7:                 RCSTA1bits.SPEN = 1;
0886  8EAB     BSF RCSTA1, 7, ACCESS
8:                 TXSTA1bits.TXEN = 1;
0888  8AAC     BSF TXSTA1, 5, ACCESS
9:             
10:                TXSTA1bits.SYNC = LCD_SYNC;
088A  98AC     BCF TXSTA1, 4, ACCESS
11:                BAUDCON1bits.BRG16 = LCD_BRG16;
088C  96A7     BCF BAUDCON1, 3, ACCESS
12:                TXSTA1bits.BRGH = LCD_BRGH;
088E  94AC     BCF TXSTA1, 2, ACCESS
13:                
14:                SPBRG1 = LCD_SPBRG;
0890  0E67     MOVLW 0x67
0892  6EAF     MOVWF SPBRG1, ACCESS
15:            }
0894  0012     RETURN 0
16:            
17:            void sendSpecialCommand(unsigned char byte) {
0896  D97D     RCALL __pa_1
18:                sendByte(0x7C); //control character
0898  0E7C     MOVLW 0x7C
089A  D1AB     BRA __pa_9
0BF2  6EE6     MOVWF POSTINC1, ACCESS
0BF4  DE7D     RCALL sendByte
0BF6  52E5     MOVF POSTDEC1, F, ACCESS
19:                sendByte(byte);
0BF8  DFD6     RCALL __pa_3
0BFA  DE7A     RCALL sendByte
0BFC  D7C8     BRA __pa_0
20:            }
21:            
22:            void sendCommand(unsigned char byte) {
089C  D97A     RCALL __pa_1
23:                sendByte(0xFE); //control character
089E  0EFE     MOVLW 0xFE
08A0  D1A8     BRA __pa_9
24:                sendByte(byte);
25:            }
26:            
27:            void setPosition(unsigned char row, unsigned char column) {
08A2  D977     RCALL __pa_1
28:                charactersSinceFill = row*16+column;
08A4  0EFD     MOVLW 0xFD
08A6  CFDB     MOVFF PLUSW2, POSTINC1
08A8  FFE6     NOP
08AA  0EFE     MOVLW 0xFE
08AC  50DB     MOVF PLUSW2, W, ACCESS
08AE  0D10     MULLW 0x10
08B0  50F3     MOVF PRODL, W, ACCESS
08B2  52E5     MOVF POSTDEC1, F, ACCESS
08B4  24E7     ADDWF INDF1, W, ACCESS
08B6  010E     MOVLB 0xE
08B8  6F12     MOVWF 0x12, BANKED
29:                sendCommand(0x80 + 64*row + column);
08BA  0EFD     MOVLW 0xFD
08BC  CFDB     MOVFF PLUSW2, POSTINC1
08BE  FFE6     NOP
08C0  0EFE     MOVLW 0xFE
08C2  50DB     MOVF PLUSW2, W, ACCESS
08C4  0D40     MULLW 0x40
08C6  50F3     MOVF PRODL, W, ACCESS
08C8  0F80     ADDLW 0x80
08CA  52E5     MOVF POSTDEC1, F, ACCESS
08CC  24E7     ADDWF INDF1, W, ACCESS
08CE  6EE6     MOVWF POSTINC1, ACCESS
08D0  DFE5     RCALL sendCommand
08D2  D15D     BRA __pa_0
30:            }
31:            
32:            void setBacklight(unsigned char brightness) {
08D4  D95E     RCALL __pa_1
33:                sendSpecialCommand(128+brightness);
08D6  0EFE     MOVLW 0xFE
08D8  CFDB     MOVFF PLUSW2, __tmp_0
08DA  F014     NOP
08DC  0E80     MOVLW 0x80
08DE  2414     ADDWF __tmp_0, W, ACCESS
08E0  6EE6     MOVWF POSTINC1, ACCESS
08E2  DFD9     RCALL sendSpecialCommand
08E4  D154     BRA __pa_0
34:            }
35:            
36:            void clear() {
37:                sendCommand(0x01);
08E6  0E01     MOVLW 0x1
08E8  6EE6     MOVWF POSTINC1, ACCESS
08EA  DFD8     RCALL sendCommand
08EC  52E5     MOVF POSTDEC1, F, ACCESS
38:            }
08EE  0012     RETURN 0
39:            
40:            void sendByte(unsigned char byte) {
08F0  CFD9     MOVFF FSR2L, POSTINC1
08F2  FFE6     NOP
08F4  CFE1     MOVFF FSR1L, FSR2L
08F6  FFD9     NOP
41:                while(!TXSTA1bits.TRMT) Nop();
08F8  B2AC     BTFSC TXSTA1, 1, ACCESS
08FA  D002     BRA 0x900
08FC  0000     NOP
08FE  D7FC     BRA 0x8F8
42:                TXREG1 = byte;
0900  0EFE     MOVLW 0xFE
0902  50DB     MOVF PLUSW2, W, ACCESS
0904  6EAD     MOVWF TXREG1, ACCESS
43:            }
0906  52E5     MOVF POSTDEC1, F, ACCESS
0908  CFE7     MOVFF INDF1, FSR2L
090A  FFD9     NOP
090C  0012     RETURN 0
44:            
45:            void sendVisibleByte(unsigned char byte) {
090E  D941     RCALL __pa_1
46:                charactersSinceFill++;
0910  010E     MOVLB 0xE
0912  2B12     INCF 0x12, F, BANKED
47:                sendByte(byte);
0914  D948     RCALL __pa_3
0916  DFEC     RCALL sendByte
0918  D13A     BRA __pa_0
0BA6  0EFE     MOVLW 0xFE
0BA8  CFDB     MOVFF PLUSW2, POSTINC1
0BAA  FFE6     NOP
0BAC  0012     RETURN 0
48:            }
49:            
50:            void sendLiteralBytes(rom const char * bytes) {
091A  D93B     RCALL __pa_1
51:                while(*bytes) {
091C  0EFD     MOVLW 0xFD
091E  CFDB     MOVFF PLUSW2, TBLPTRL
0920  FFF6     NOP
0922  0EFE     MOVLW 0xFE
0924  CFDB     MOVFF PLUSW2, TBLPTRH
0926  FFF7     NOP
0928  0008     TBLRD*
092A  50F5     MOVF TABLAT, W, ACCESS
092C  E00F     BZ 0x94C
094A  D7E8     BRA 0x91C
52:                    sendVisibleByte(*bytes++);
092E  0EFD     MOVLW 0xFD
0930  CFDB     MOVFF PLUSW2, TBLPTRL
0932  FFF6     NOP
0934  2ADB     INCF PLUSW2, F, ACCESS
0936  0EFE     MOVLW 0xFE
0938  CFDB     MOVFF PLUSW2, TBLPTRH
093A  FFF7     NOP
093C  E301     BNC 0x940
093E  2ADB     INCF PLUSW2, F, ACCESS
0940  0008     TBLRD*
0942  50F5     MOVF TABLAT, W, ACCESS
0944  6EE6     MOVWF POSTINC1, ACCESS
0946  DFE3     RCALL sendVisibleByte
0948  52E5     MOVF POSTDEC1, F, ACCESS
53:                }
54:            }
094C  D158     BRA __pa_10
55:            
56:            void sendDigit(unsigned char digit) {
094E  D921     RCALL __pa_1
57:                if (digit >= 10)
0950  0E0A     MOVLW 0xA
0952  6EF3     MOVWF PRODL, ACCESS
0954  0EFE     MOVLW 0xFE
0956  CFDB     MOVFF PLUSW2, PRODH
0958  FFF4     NOP
095A  50F3     MOVF PRODL, W, ACCESS
095C  5CF4     SUBWF PRODH, W, ACCESS
095E  E305     BNC 0x96A
58:                    sendVisibleByte(digit + 65 - 10);
0960  0EFE     MOVLW 0xFE
0962  50DB     MOVF PLUSW2, W, ACCESS
0964  0F41     ADDLW 0x41
0966  0FF6     ADDLW 0xF6
59:                else
0968  D003     BRA 0x970
60:                    sendVisibleByte(digit + 48);
096A  0EFE     MOVLW 0xFE
096C  50DB     MOVF PLUSW2, W, ACCESS
096E  0F30     ADDLW 0x30
0970  6EE6     MOVWF POSTINC1, ACCESS
0972  DFCD     RCALL sendVisibleByte
0974  D10C     BRA __pa_0
61:            }
62:            
63:            void sendCharAsBase(unsigned char num, unsigned char base, unsigned char padOutput) {
0976  D90D     RCALL __pa_1
0978  0E0B     MOVLW 0xB
097A  26E1     ADDWF FSR1L, F, ACCESS
64:                unsigned char quotient;
65:                unsigned char remainder;
66:                unsigned char i = 0;
097C  0E02     MOVLW 0x2
097E  6ADB     CLRF PLUSW2, ACCESS
67:                unsigned char digits[8];
68:                
69:                while((padOutput == 0 && quotient != 0) || (padOutput != 0 && i < 8)) {
0980  0EFC     MOVLW 0xFC
0982  50DB     MOVF PLUSW2, W, ACCESS
0984  E102     BNZ 0x98A
0986  50DF     MOVF INDF2, W, ACCESS
0988  E10B     BNZ 0x9A0
098A  0EFC     MOVLW 0xFC
098C  50DB     MOVF PLUSW2, W, ACCESS
098E  E02E     BZ 0x9EC
0990  0E08     MOVLW 0x8
0992  6EF3     MOVWF PRODL, ACCESS
0994  0E02     MOVLW 0x2
0996  CFDB     MOVFF PLUSW2, PRODH
0998  FFF4     NOP
099A  50F3     MOVF PRODL, W, ACCESS
099C  5CF4     SUBWF PRODH, W, ACCESS
099E  E226     BC 0x9EC
09EA  D7CA     BRA 0x980
70:                    quotient = num / base;
09A0  0EFD     MOVLW 0xFD
09A2  CFDB     MOVFF PLUSW2, __tmp_0
09A4  F014     NOP
09A6  C014     MOVFF __tmp_0, 0xE
09A8  F00E     NOP
09AA  0EFE     MOVLW 0xFE
09AC  CFDB     MOVFF PLUSW2, 0x9
09AE  F009     NOP
09B0  ECD2     CALL 0xDA4, 0
09B2  F006     NOP
09B4  5009     MOVF 0x9, W, ACCESS
09B6  6EDF     MOVWF INDF2, ACCESS
71:            
72:                    remainder = num - quotient*base;
09B8  0EFE     MOVLW 0xFE
09BA  CFDB     MOVFF PLUSW2, POSTINC1
09BC  FFE6     NOP
09BE  0EFD     MOVLW 0xFD
09C0  50DB     MOVF PLUSW2, W, ACCESS
09C2  02DF     MULWF INDF2, ACCESS
09C4  50F3     MOVF PRODL, W, ACCESS
09C6  52E5     MOVF POSTDEC1, F, ACCESS
09C8  5CE7     SUBWF INDF1, W, ACCESS
09CA  6EE7     MOVWF INDF1, ACCESS
09CC  0E01     MOVLW 0x1
09CE  CFE7     MOVFF INDF1, PLUSW2
09D0  FFDB     NOP
73:                    num = quotient;
09D2  0EFE     MOVLW 0xFE
09D4  CFDF     MOVFF INDF2, PLUSW2
09D6  FFDB     NOP
74:            
75:                    digits[i++] = remainder;
09D8  D8EA     RCALL __pa_4
09DA  CFDB     MOVFF PLUSW2, PRODL
09DC  FFF3     NOP
09DE  2ADB     INCF PLUSW2, F, ACCESS
09E0  50F3     MOVF PRODL, W, ACCESS
09E2  D8EC     RCALL __pa_5
09E4  0E01     MOVLW 0x1
09E6  CFDB     MOVFF PLUSW2, INDF0
09E8  FFEF     NOP
0BAE  50D9     MOVF FSR2L, W, ACCESS
0BB0  0F03     ADDLW 0x3
0BB2  6E14     MOVWF __tmp_0, ACCESS
0BB4  CFDA     MOVFF FSR2H, 0x15
0BB6  F015     NOP
0BB8  0E02     MOVLW 0x2
0BBA  0012     RETURN 0
0BBC  010F     MOVLB 0xF
0BBE  2414     ADDWF __tmp_0, W, ACCESS
0BC0  6EE9     MOVWF FSR0L, ACCESS
0BC2  0E00     MOVLW 0x0
0BC4  20DA     ADDWFC FSR2H, W, ACCESS
0BC6  6EEA     MOVWF FSR0H, ACCESS
0BC8  0012     RETURN 0
76:                }
77:                
78:                while (i != 0) {
09EC  0E02     MOVLW 0x2
09EE  50DB     MOVF PLUSW2, W, ACCESS
09F0  E009     BZ 0xA04
0A02  D7F4     BRA 0x9EC
79:                    sendDigit(digits[--i]);
09F2  D8DD     RCALL __pa_4
09F4  06DB     DECF PLUSW2, F, ACCESS
09F6  50DB     MOVF PLUSW2, W, ACCESS
09F8  D8E1     RCALL __pa_5
09FA  50EF     MOVF INDF0, W, ACCESS
09FC  6EE6     MOVWF POSTINC1, ACCESS
09FE  DFA7     RCALL sendDigit
0A00  52E5     MOVF POSTDEC1, F, ACCESS
80:                }
81:            }
0A04  0E0B     MOVLW 0xB
0A06  5CE1     SUBWF FSR1L, W, ACCESS
0A08  E202     BC 0xA0E
0A0A  6AE1     CLRF FSR1L, ACCESS
0A0C  52E5     MOVF POSTDEC1, F, ACCESS
0A0E  6EE1     MOVWF FSR1L, ACCESS
0A10  D0F6     BRA __pa_10
82:            
83:            void sendIntAsBase(unsigned int num, unsigned int base) {
0A12  D8BF     RCALL __pa_1
0A14  0E14     MOVLW 0x14
0A16  26E1     ADDWF FSR1L, F, ACCESS
84:                unsigned int quotient;
85:                char remainder;
86:                char i = 0;
0A18  0E03     MOVLW 0x3
0A1A  6ADB     CLRF PLUSW2, ACCESS
87:                char digits[16];
88:            
89:                while(1) {
90:                    quotient = num / base;
0A1C  0EFD     MOVLW 0xFD
0A1E  CFDB     MOVFF PLUSW2, 0x8
0A20  F008     NOP
0A22  0EFE     MOVLW 0xFE
0A24  CFDB     MOVFF PLUSW2, 0x9
0A26  F009     NOP
0A28  0EFB     MOVLW 0xFB
0A2A  CFDB     MOVFF PLUSW2, 0xD
0A2C  F00D     NOP
0A2E  0EFC     MOVLW 0xFC
0A30  CFDB     MOVFF PLUSW2, 0xE
0A32  F00E     NOP
0A34  EC8D     CALL 0xD1A, 0
0A36  F006     NOP
0A38  C008     MOVFF 0x8, POSTINC2
0A3A  FFDE     NOP
0A3C  C009     MOVFF 0x9, POSTDEC2
0A3E  FFDD     NOP
91:                    remainder = (char)(num - quotient*base);
0A40  0EFD     MOVLW 0xFD
0A42  CFDB     MOVFF PLUSW2, 0x16
0A44  F016     NOP
0A46  0EFE     MOVLW 0xFE
0A48  CFDB     MOVFF PLUSW2, 0x17
0A4A  F017     NOP
0A4C  0EFB     MOVLW 0xFB
0A4E  CFDB     MOVFF PLUSW2, 0x8
0A50  F008     NOP
0A52  0EFC     MOVLW 0xFC
0A54  CFDB     MOVFF PLUSW2, 0x9
0A56  F009     NOP
0A58  CFDE     MOVFF POSTINC2, 0xD
0A5A  F00D     NOP
0A5C  CFDD     MOVFF POSTDEC2, 0xE
0A5E  F00E     NOP
0A60  EC58     CALL 0xCB0, 0
0A62  F006     NOP
0A64  5006     MOVF n, W, ACCESS
0A66  5C16     SUBWF 0x16, W, ACCESS
0A68  6E14     MOVWF __tmp_0, ACCESS
0A6A  5007     MOVF 0x7, W, ACCESS
0A6C  5817     SUBWFB 0x17, W, ACCESS
0A6E  0E02     MOVLW 0x2
0A70  C014     MOVFF __tmp_0, PLUSW2
0A72  FFDB     NOP
92:                    num = quotient;
0A74  CFD9     MOVFF FSR2L, FSR0L
0A76  FFE9     NOP
0A78  CFDA     MOVFF FSR2H, FSR0H
0A7A  FFEA     NOP
0A7C  0EFD     MOVLW 0xFD
0A7E  CFEE     MOVFF POSTINC0, PLUSW2
0A80  FFDB     NOP
0A82  0EFE     MOVLW 0xFE
0A84  CFED     MOVFF POSTDEC0, PLUSW2
0A86  FFDB     NOP
93:            
94:                    digits[i++] = remainder;
0A88  D8A0     RCALL __pa_6
0A8A  CFDB     MOVFF PLUSW2, PRODL
0A8C  FFF3     NOP
0A8E  2ADB     INCF PLUSW2, F, ACCESS
0A90  50F3     MOVF PRODL, W, ACCESS
0A92  6E16     MOVWF 0x16, ACCESS
0A94  6A17     CLRF 0x17, ACCESS
0A96  BE16     BTFSC 0x16, 7, ACCESS
0A98  6817     SETF 0x17, ACCESS
0A9A  D89E     RCALL __pa_7
0A9C  0E02     MOVLW 0x2
0A9E  CFDB     MOVFF PLUSW2, INDF0
0AA0  FFEF     NOP
0BCA  50D9     MOVF FSR2L, W, ACCESS
0BCC  0F04     ADDLW 0x4
0BCE  6E14     MOVWF __tmp_0, ACCESS
0BD0  CFDA     MOVFF FSR2H, 0x15
0BD2  F015     NOP
0BD4  0E03     MOVLW 0x3
0BD6  0012     RETURN 0
0BD8  5014     MOVF __tmp_0, W, ACCESS
0BDA  2416     ADDWF 0x16, W, ACCESS
0BDC  6EE9     MOVWF FSR0L, ACCESS
0BDE  5015     MOVF 0x15, W, ACCESS
0BE0  2017     ADDWFC 0x17, W, ACCESS
0BE2  6EEA     MOVWF FSR0H, ACCESS
0BE4  0012     RETURN 0
95:            
96:                    if (quotient == 0) break;
0AA2  CFD9     MOVFF FSR2L, FSR0L
0AA4  FFE9     NOP
0AA6  CFDA     MOVFF FSR2H, FSR0H
0AA8  FFEA     NOP
0AAA  50EE     MOVF POSTINC0, W, ACCESS
0AAC  10ED     IORWF POSTDEC0, W, ACCESS
0AAE  E1B6     BNZ 0xA1C
97:                }
98:            
99:                while (i != 0) {
0AB0  0E03     MOVLW 0x3
0AB2  50DB     MOVF PLUSW2, W, ACCESS
0AB4  E00D     BZ 0xAD0
0ACE  D7F0     BRA 0xAB0
100:                   sendDigit(digits[--i]);
0AB6  D889     RCALL __pa_6
0AB8  06DB     DECF PLUSW2, F, ACCESS
0ABA  CFDB     MOVFF PLUSW2, 0x16
0ABC  F016     NOP
0ABE  6A17     CLRF 0x17, ACCESS
0AC0  BE16     BTFSC 0x16, 7, ACCESS
0AC2  6817     SETF 0x17, ACCESS
0AC4  D889     RCALL __pa_7
0AC6  50EF     MOVF INDF0, W, ACCESS
0AC8  6EE6     MOVWF POSTINC1, ACCESS
0ACA  DF41     RCALL sendDigit
0ACC  52E5     MOVF POSTDEC1, F, ACCESS
101:               }
102:           }
0AD0  0E14     MOVLW 0x14
0AD2  5CE1     SUBWF FSR1L, W, ACCESS
0AD4  E202     BC 0xADA
0AD6  6AE1     CLRF FSR1L, ACCESS
0AD8  52E5     MOVF POSTDEC1, F, ACCESS
0ADA  6EE1     MOVWF FSR1L, ACCESS
0ADC  D090     BRA __pa_10
103:           
104:           void sendDec(unsigned char num) {
0ADE  D859     RCALL __pa_1
105:               sendCharAsBase(num,10,0);
0AE0  6AE6     CLRF POSTINC1, ACCESS
0AE2  0E0A     MOVLW 0xA
0AE4  D080     BRA __pa_8
106:           }
107:           
108:           void sendIntDec(unsigned int num) {
0AE6  D855     RCALL __pa_1
109:               sendIntAsBase(num,10);
0AE8  0E0A     MOVLW 0xA
0AEA  6EE6     MOVWF POSTINC1, ACCESS
0AEC  6AE6     CLRF POSTINC1, ACCESS
0AEE  0EFD     MOVLW 0xFD
0AF0  CFDB     MOVFF PLUSW2, POSTINC1
0AF2  FFE6     NOP
0AF4  D858     RCALL __pa_3
0AF6  DF8D     RCALL sendIntAsBase
0AF8  52E5     MOVF POSTDEC1, F, ACCESS
0AFA  52E5     MOVF POSTDEC1, F, ACCESS
0AFC  52E5     MOVF POSTDEC1, F, ACCESS
0AFE  D047     BRA __pa_0
110:           }
111:           
112:           void sendHex(unsigned char num) {
0B00  D848     RCALL __pa_1
113:               sendLiteralBytes("0x");
0B02  0E4B     MOVLW 0x4B
0B04  6EE6     MOVWF POSTINC1, ACCESS
0B06  0E0D     MOVLW 0xD
0B08  D849     RCALL __pa_2
114:               sendCharAsBase(num,16,0);
0B0A  6AE6     CLRF POSTINC1, ACCESS
0B0C  0E10     MOVLW 0x10
0B0E  D06B     BRA __pa_8
115:           }
116:           
117:           void sendBin(unsigned char num) {
0B10  D87A     RCALL __pa_11
0C06  DFC5     RCALL __pa_1
118:               sendLiteralBytes("0b");
0B9C  6EE6     MOVWF POSTINC1, ACCESS
0B9E  DEBD     RCALL sendLiteralBytes
0BA0  52E5     MOVF POSTDEC1, F, ACCESS
0BA2  52E5     MOVF POSTDEC1, F, ACCESS
0BA4  0012     RETURN 0
0C08  0E48     MOVLW 0x48
0C0A  6EE6     MOVWF POSTINC1, ACCESS
0C0C  0E0D     MOVLW 0xD
0C0E  EFCE     GOTO 0xB9C
0C10  F005     NOP
119:               sendCharAsBase(num,2,0);
0B12  6AE6     CLRF POSTINC1, ACCESS
0B14  0E02     MOVLW 0x2
0B16  D067     BRA __pa_8
120:           }
121:           
122:           void sendBinPad(unsigned char num) {
0B18  D876     RCALL __pa_11
123:               sendLiteralBytes("0b");
124:               sendCharAsBase(num,2,1);
0B1A  0E01     MOVLW 0x1
0B1C  6EE6     MOVWF POSTINC1, ACCESS
0B1E  0E02     MOVLW 0x2
0B20  D062     BRA __pa_8
0BE6  6EE6     MOVWF POSTINC1, ACCESS
0BE8  DFDE     RCALL __pa_3
0BEA  DEC5     RCALL sendCharAsBase
0BEC  52E5     MOVF POSTDEC1, F, ACCESS
0BEE  52E5     MOVF POSTDEC1, F, ACCESS
0BF0  D7CE     BRA __pa_0
125:           }
126:           
127:           void fill(void) {
0B22  D837     RCALL __pa_1
0B24  52E6     MOVF POSTINC1, F, ACCESS
128:               char i = 16*2-charactersSinceFill-1;
0B26  0E20     MOVLW 0x20
0B28  010E     MOVLB 0xE
0B2A  80D8     BSF STATUS, 0, ACCESS
0B2C  5512     SUBFWB 0x12, W, BANKED
0B2E  0FFF     ADDLW 0xFF
0B30  6EDF     MOVWF INDF2, ACCESS
129:               //sendDec(i);
130:               
131:               while(i-- >= 0) {
0B32  50DF     MOVF INDF2, W, ACCESS
0B34  06DF     DECF INDF2, F, ACCESS
0B36  6E14     MOVWF __tmp_0, ACCESS
0B38  34E8     RLCF WREG, W, ACCESS
0B3A  E205     BC 0xB46
0B44  D7F6     BRA 0xB32
132:                   sendLiteralBytes(" ");
0B3C  0E46     MOVLW 0x46
0B3E  6EE6     MOVWF POSTINC1, ACCESS
0B40  0E0D     MOVLW 0xD
0B42  D82C     RCALL __pa_2
133:               }
134:               charactersSinceFill = 0;
0B46  010E     MOVLB 0xE
0B48  6B12     CLRF 0x12, BANKED
135:           }
0B4A  D021     BRA __pa_0
136:           
137:           void fillLine(void) {
0B4C  D822     RCALL __pa_1
0B4E  52E6     MOVF POSTINC1, F, ACCESS
0B92  CFD9     MOVFF FSR2L, POSTINC1
0B94  FFE6     NOP
0B96  CFE1     MOVFF FSR1L, FSR2L
0B98  FFD9     NOP
0B9A  0012     RETURN 0
138:               char i = 16-charactersSinceFill-1;
0B50  0E10     MOVLW 0x10
0B52  010E     MOVLB 0xE
0B54  80D8     BSF STATUS, 0, ACCESS
0B56  5512     SUBFWB 0x12, W, BANKED
0B58  0FFF     ADDLW 0xFF
0B5A  6EDF     MOVWF INDF2, ACCESS
139:               if (charactersSinceFill >= 16) {
0B5C  0E10     MOVLW 0x10
0B5E  6EE7     MOVWF INDF1, ACCESS
0B60  1912     XORWF 0x12, W, BANKED
0B62  AEE8     BTFSS WREG, 7, ACCESS
0B64  D002     BRA 0xB6A
0B66  34E7     RLCF INDF1, W, ACCESS
0B68  D002     BRA 0xB6E
0B6A  50E7     MOVF INDF1, W, ACCESS
0B6C  5D12     SUBWF 0x12, W, BANKED
0B6E  E302     BNC 0xB74
140:                   fill();
0B70  DFD8     RCALL fill
141:                   return;
0B72  D00C     BRA 0xB8C
142:               }
143:           
144:               while(i-- >= 0) {
0B74  50DF     MOVF INDF2, W, ACCESS
0B76  06DF     DECF INDF2, F, ACCESS
0B78  6E14     MOVWF __tmp_0, ACCESS
0B7A  34E8     RLCF WREG, W, ACCESS
0B7C  E207     BC 0xB8C
0B8A  D7F4     BRA 0xB74
145:                   sendLiteralBytes(" ");
0B7E  0E46     MOVLW 0x46
0B80  6EE6     MOVWF POSTINC1, ACCESS
0B82  0E0D     MOVLW 0xD
0B84  D80B     RCALL __pa_2
146:                   charactersSinceFill ++;
0B86  010E     MOVLB 0xE
0B88  2B12     INCF 0x12, F, BANKED
147:               }
148:           }
0B8C  D000     BRA __pa_0
0B8E  52E5     MOVF POSTDEC1, F, ACCESS
0B90  D036     BRA __pa_10
0BFE  52E5     MOVF POSTDEC1, F, ACCESS
0C00  CFE7     MOVFF INDF1, FSR2L
0C02  FFD9     NOP
0C04  0012     RETURN 0
---  /home/julian/Hobby/Development/tinkering/julianh2_tinkering/pic18f25k80.X/nRF2401.c  ---------------
1:             #include "nRF2401.h"
2:             #include "constants.h"
3:             
4:             //****************************************************/
5:             // SPI(nRF24L01) commands
6:             #define READ_REG        0x00  // Define read command to register
7:             #define WRITE_REG       0x20  // Define write command to register
8:             #define ACTIVATE		0x50  // follow with 0x73 to activate feature register
9:             #define R_RX_PL_WID     0x60  // Define RX payload length
10:            #define RD_RX_PLOAD     0x61  // Define RX payload register address
11:            #define WR_TX_PLOAD     0xA0  // Define TX payload register address
12:            #define WR_TX_PLOAD_NOACK     0xB0  // Define TX payload with no ACK 
13:            #define W_ACK_PAYLOAD   0xA8  // Define ACK payload (default = Pipe0)
14:            #define FLUSH_TX        0xE1  // Define flush TX register command
15:            #define FLUSH_RX        0xE2  // Define flush RX register command
16:            #define REUSE_TX_PL     0xE3  // Define reuse TX payload register command
17:            #define NRF_NOP             0xFF  // Define No Operation, might be used to read status register
18:            //***************************************************/
19:            #define RX_DR    0x40
20:            #define TX_DS    0x20
21:            #define MAX_RT   0x10
22:            //*********	******************************************/
23:            // SPI(nRF24L01) registers(addresses)
24:            #define CONFIG          0x00  // 'Config' register address
25:            #define EN_AA           0x01  // 'Enable Auto Acknowledgment' register address
26:            #define EN_RXADDR       0x02  // 'Enabled RX addresses' register address
27:            #define SETUP_AW        0x03  // 'Setup address width' register address
28:            #define SETUP_RETR      0x04  // 'Setup Auto. Retrans' register address
29:            #define RF_CH           0x05  // 'RF channel' register address
30:            #define RF_SETUP        0x06  // 'RF setup' register address
31:            #define STATUS_REG      0x07  // 'Status' register address
32:            #define OBSERVE_TX      0x08  // 'Observe TX' register address
33:            #define CD              0x09  // 'Carrier Detect' register address
34:            #define RX_ADDR_P0      0x0A  // 'RX address pipe0' register address
35:            #define RX_ADDR_P1      0x0B  // 'RX address pipe1' register address
36:            #define RX_ADDR_P2      0x0C  // 'RX address pipe2' register address
37:            #define RX_ADDR_P3      0x0D  // 'RX address pipe3' register address
38:            #define RX_ADDR_P4      0x0E  // 'RX address pipe4' register address
39:            #define RX_ADDR_P5      0x0F  // 'RX address pipe5' register address
40:            #define TX_ADDR         0x10  // 'TX address' register address
41:            #define RX_PW_P0        0x11  // 'RX payload width, pipe0' register address
42:            #define RX_PW_P1        0x12  // 'RX payload width, pipe1' register address
43:            #define RX_PW_P2        0x13  // 'RX payload width, pipe2' register address
44:            #define RX_PW_P3        0x14  // 'RX payload width, pipe3' register address
45:            #define RX_PW_P4        0x15  // 'RX payload width, pipe4' register address
46:            #define RX_PW_P5        0x16  // 'RX payload width, pipe5' register address
47:            #define FIFO_STATUS     0x17  // 'FIFO Status Register' register address
48:            #define DYNPD    		0x1C  // per pipe DPL control
49:            #define FEATURE    		0x1D  // 'Feature' register address
50:            
51:            #define nrf_SET 1
52:            #define nrf_CLEAR 0
53:            #define nrf_INPUT 1
54:            #define nrf_OUTPUT 0
55:            
56:            #define TX_ADR_WIDTH    5   // 5 unsigned chars TX(RX) address width
57:            #define TX_PLOAD_WIDTH  32  // 4 unsigned chars TX payload
58:            #define ACK_PAYLOAD 2
59:            
60:            #define NO_ACK			0x00
61:            #define YES_ACK			0x01
62:            #define NO_DATA			0x00
63:            #define YES_DATA		0x01
64:            
65:            unsigned char TX_ADDRESS[TX_ADR_WIDTH] = {0x34,0x43,0x10,0x10,0x00}; // Define a static TX address
66:            
67:            unsigned char nrf_SPI_RW(unsigned char);
68:            unsigned char nrf_SPI_RW_Reg(unsigned char, unsigned char);
69:            unsigned char nrf_SPI_Read(unsigned char);
70:            unsigned char nrf_SPI_Read_Buf(unsigned char, unsigned char *, unsigned char);
71:            unsigned char nrf_SPI_Write_Buf(unsigned char, unsigned char *, unsigned char);
72:            
73:            unsigned char nrf_getStatus(void) {
0492  D9F5     RCALL __pa_24
74:                unsigned char status;
75:                CSN = nrf_CLEAR;
0494  9081     BCF PORTB, 0, ACCESS
76:                SSPBUF = 0xFF;
0496  68C9     SETF SSPBUF, ACCESS
77:                while(!SSPSTATbits.BF);
0498  A0C7     BTFSS SSPSTAT, 0, ACCESS
049A  D7FE     BRA 0x498
78:                status = SSPBUF;
049C  50C9     MOVF SSPBUF, W, ACCESS
049E  6EDF     MOVWF INDF2, ACCESS
79:                CSN = nrf_SET;
04A0  D1DF     BRA __pa_20
80:                return status;
81:            }
82:            
83:            unsigned char nrf_send(unsigned char * tx_buf, unsigned char * rx_buf) {
04A2  D9B5     RCALL __pa_14
080E  DFA9     RCALL __pa_2
0810  0E03     MOVLW 0x3
0812  26E1     ADDWF FSR1L, F, ACCESS
84:                char status;
85:                int i;
86:            
87:                nrf_SPI_RW_Reg(FLUSH_TX,0);
0814  D830     RCALL __pa_23
0876  6AE6     CLRF POSTINC1, ACCESS
0878  0EE1     MOVLW 0xE1
087A  EFA5     GOTO 0x74A
087C  F003     NOP
88:                
89:                status = nrf_getStatus();
0816  DE3D     RCALL nrf_getStatus
0818  DFF6     RCALL __pa_13
90:                nrf_SPI_RW_Reg(WRITE_REG + STATUS_REG, status);	//nrf_CLEAR max RT bit
081A  0E27     MOVLW 0x27
081C  DF96     RCALL __pa_0
91:                nrf_SPI_Write_Buf(WR_TX_PLOAD,tx_buf,TX_PLOAD_WIDTH); //load the data into the NRF
04A4  0EA0     MOVLW 0xA0
04A6  D956     RCALL __pa_1
081E  0E20     MOVLW 0x20
0820  EFDC     GOTO 0x7B8
0822  F003     NOP
92:            
93:                //wait for response
94:                CE = nrf_SET;
04A8  8281     BSF PORTB, 1, ACCESS
95:                for(i=0; i<2000; i++);
04AA  0E01     MOVLW 0x1
04AC  6ADB     CLRF PLUSW2, ACCESS
04AE  0E02     MOVLW 0x2
04B0  6ADB     CLRF PLUSW2, ACCESS
04B2  0E01     MOVLW 0x1
04B4  CFDB     MOVFF PLUSW2, __tmp_0
04B6  F014     NOP
04B8  0E02     MOVLW 0x2
04BA  CFDB     MOVFF PLUSW2, 0x15
04BC  F015     NOP
04BE  90D8     BCF STATUS, 0, ACCESS
04C0  5015     MOVF 0x15, W, ACCESS
04C2  E604     BN 0x4CC
04C4  0ED0     MOVLW 0xD0
04C6  5C14     SUBWF __tmp_0, W, ACCESS
04C8  0E07     MOVLW 0x7
04CA  5815     SUBWFB 0x15, W, ACCESS
04CC  E206     BC 0x4DA
04CE  0E01     MOVLW 0x1
04D0  2ADB     INCF PLUSW2, F, ACCESS
04D2  0E02     MOVLW 0x2
04D4  E3EE     BNC 0x4B2
04D6  2ADB     INCF PLUSW2, F, ACCESS
04D8  D7EC     BRA 0x4B2
96:                CE = nrf_CLEAR;
04DA  9281     BCF PORTB, 1, ACCESS
97:            
98:                status = nrf_getStatus();
04DC  DFDA     RCALL nrf_getStatus
04DE  6EDF     MOVWF INDF2, ACCESS
99:                if(status & RX_DR) {
04E0  ACDF     BTFSS INDF2, 6, ACCESS
04E2  D00B     BRA 0x4FA
100:                   nrf_SPI_RW_Reg(WRITE_REG + STATUS_REG, RX_DR);		
04E4  0E40     MOVLW 0x40
04E6  6EE6     MOVWF POSTINC1, ACCESS
04E8  0E27     MOVLW 0x27
04EA  D92F     RCALL __pa_0
101:                   nrf_SPI_Read_Buf(RD_RX_PLOAD,rx_buf,ACK_PAYLOAD);
04EC  0E02     MOVLW 0x2
04EE  D94E     RCALL __pa_6
078C  6EE6     MOVWF POSTINC1, ACCESS
078E  0EFB     MOVLW 0xFB
0790  CFDB     MOVFF PLUSW2, POSTINC1
0792  FFE6     NOP
0794  0EFC     MOVLW 0xFC
0796  CFDB     MOVFF PLUSW2, POSTINC1
0798  FFE6     NOP
079A  0E61     MOVLW 0x61
079C  6EE6     MOVWF POSTINC1, ACCESS
079E  DF98     RCALL nrf_SPI_Read_Buf
07A0  52E5     MOVF POSTDEC1, F, ACCESS
07A2  52E5     MOVF POSTDEC1, F, ACCESS
07A4  52E5     MOVF POSTDEC1, F, ACCESS
07A6  52E5     MOVF POSTDEC1, F, ACCESS
07A8  0012     RETURN 0
102:                   nrf_SPI_RW_Reg(FLUSH_RX,0);
04F0  6AE6     CLRF POSTINC1, ACCESS
04F2  0EE2     MOVLW 0xE2
04F4  D92A     RCALL __pa_0
103:                   return YES_ACK;
04F6  0E01     MOVLW 0x1
04F8  D001     BRA 0x4FC
104:               } else {
105:                   return NO_ACK;
04FA  0E00     MOVLW 0x0
106:               }
107:           }
04FC  6E14     MOVWF __tmp_0, ACCESS
04FE  0E03     MOVLW 0x3
0500  5CE1     SUBWF FSR1L, W, ACCESS
0502  E202     BC 0x508
0504  6AE1     CLRF FSR1L, ACCESS
0506  52E5     MOVF POSTDEC1, F, ACCESS
0508  6EE1     MOVWF FSR1L, ACCESS
050A  5014     MOVF __tmp_0, W, ACCESS
050C  D12F     BRA __pa_3
108:           
109:           void nrf_send_noack(unsigned char * tx_buf, unsigned char * rx_buf) {
050E  D97F     RCALL __pa_14
110:               char status;
111:               int i;
112:           
113:               nrf_SPI_RW_Reg(FLUSH_TX,0);
114:           
115:               status = nrf_getStatus();
0806  6EDF     MOVWF INDF2, ACCESS
116:               nrf_SPI_RW_Reg(WRITE_REG + STATUS_REG, status);	//nrf_CLEAR max RT bit
0808  CFDF     MOVFF INDF2, POSTINC1
080A  FFE6     NOP
080C  0012     RETURN 0
117:               nrf_SPI_Write_Buf(WR_TX_PLOAD_NOACK,tx_buf,TX_PLOAD_WIDTH); //load the data into the NRF
0510  0EB0     MOVLW 0xB0
0512  D920     RCALL __pa_1
0754  6EE6     MOVWF POSTINC1, ACCESS
0756  DFDB     RCALL nrf_SPI_Write_Buf
0758  52E5     MOVF POSTDEC1, F, ACCESS
075A  52E5     MOVF POSTDEC1, F, ACCESS
075C  52E5     MOVF POSTDEC1, F, ACCESS
075E  52E5     MOVF POSTDEC1, F, ACCESS
0760  0012     RETURN 0
118:           
119:               CE = nrf_SET;
0514  8281     BSF PORTB, 1, ACCESS
120:           }
0516  0E03     MOVLW 0x3
0518  5CE1     SUBWF FSR1L, W, ACCESS
051A  E202     BC 0x520
051C  6AE1     CLRF FSR1L, ACCESS
051E  52E5     MOVF POSTDEC1, F, ACCESS
0520  6EE1     MOVWF FSR1L, ACCESS
0522  D124     BRA __pa_3
121:           
122:           unsigned char nrf_receive(unsigned char * tx_buf, unsigned char * rx_buf) {
0524  D91E     RCALL __pa_2
0526  0E04     MOVLW 0x4
0528  26E1     ADDWF FSR1L, F, ACCESS
123:               char status;
124:               char ffstat;
125:               char config;
126:               char ffstatcount;
127:           
128:               //------ load ACK payload data -------------
129:           
130:               nrf_SPI_RW_Reg(FLUSH_TX,0);
052A  D9A5     RCALL __pa_23
131:               nrf_SPI_Write_Buf(W_ACK_PAYLOAD,tx_buf,ACK_PAYLOAD);
052C  0E02     MOVLW 0x2
052E  D944     RCALL __pa_8
0530  0EA8     MOVLW 0xA8
0532  D910     RCALL __pa_1
07B8  6EE6     MOVWF POSTINC1, ACCESS
07BA  0EFD     MOVLW 0xFD
07BC  CFDB     MOVFF PLUSW2, POSTINC1
07BE  FFE6     NOP
07C0  0EFE     MOVLW 0xFE
07C2  CFDB     MOVFF PLUSW2, POSTINC1
07C4  FFE6     NOP
07C6  0012     RETURN 0
132:           
133:               //config = nrf_SPI_Read(CONFIG);
134:           
135:               status = nrf_getStatus();
0534  DFAE     RCALL nrf_getStatus
0536  6EDF     MOVWF INDF2, ACCESS
136:               ffstat = nrf_SPI_Read(FIFO_STATUS);
0538  D94F     RCALL __pa_10
07D8  0E17     MOVLW 0x17
07DA  D846     RCALL __pa_21
07DC  6EE7     MOVWF INDF1, ACCESS
07DE  0E01     MOVLW 0x1
07E0  CFE7     MOVFF INDF1, PLUSW2
07E2  FFDB     NOP
07E4  0012     RETURN 0
0868  6EE6     MOVWF POSTINC1, ACCESS
086A  DF2C     RCALL nrf_SPI_Read
086C  52E5     MOVF POSTDEC1, F, ACCESS
086E  0012     RETURN 0
137:           
138:               if(((status & RX_DR))||(!(ffstat & 0x01))) {
053A  0E40     MOVLW 0x40
053C  14DF     ANDWF INDF2, W, ACCESS
053E  E104     BNZ 0x548
0540  0E01     MOVLW 0x1
0542  50DB     MOVF PLUSW2, W, ACCESS
0544  0B01     ANDLW 0x1
0546  E120     BNZ 0x588
139:                   ffstatcount = 0;
0548  0E03     MOVLW 0x3
054A  6ADB     CLRF PLUSW2, ACCESS
140:                   while((ffstatcount++ < 4) && ((ffstat & 0x01) == 0)) {
054C  0E03     MOVLW 0x3
054E  CFDB     MOVFF PLUSW2, PRODL
0550  FFF3     NOP
0552  2ADB     INCF PLUSW2, F, ACCESS
0554  50F3     MOVF PRODL, W, ACCESS
0556  6E14     MOVWF __tmp_0, ACCESS
0558  0E04     MOVLW 0x4
055A  6EE7     MOVWF INDF1, ACCESS
055C  18F3     XORWF PRODL, W, ACCESS
055E  AEE8     BTFSS WREG, 7, ACCESS
0560  D002     BRA 0x566
0562  34E7     RLCF INDF1, W, ACCESS
0564  D002     BRA 0x56A
0566  50E7     MOVF INDF1, W, ACCESS
0568  5C14     SUBWF __tmp_0, W, ACCESS
056A  E208     BC 0x57C
056C  0E01     MOVLW 0x1
056E  50DB     MOVF PLUSW2, W, ACCESS
0570  0B01     ANDLW 0x1
0572  E104     BNZ 0x57C
057A  D7E8     BRA 0x54C
141:                       //read entire buffer---------
142:                       nrf_SPI_Read_Buf(RD_RX_PLOAD,rx_buf,32);
0574  0E20     MOVLW 0x20
0576  D90A     RCALL __pa_6
143:                       ffstat = nrf_SPI_Read(FIFO_STATUS);
0578  D92F     RCALL __pa_10
144:                   }
145:                   nrf_SPI_RW_Reg(WRITE_REG + STATUS_REG, 0x70);	//nrf_CLEAR all flags
057C  0E70     MOVLW 0x70
057E  6EE6     MOVWF POSTINC1, ACCESS
0580  0E27     MOVLW 0x27
0582  D8E3     RCALL __pa_0
146:                   return YES_DATA;
0584  0E01     MOVLW 0x1
0586  D001     BRA 0x58A
147:               } else {
148:                   return NO_DATA;
0588  0E00     MOVLW 0x0
149:               }
150:           }
058A  6E14     MOVWF __tmp_0, ACCESS
058C  0E04     MOVLW 0x4
058E  5CE1     SUBWF FSR1L, W, ACCESS
0590  E202     BC 0x596
0592  6AE1     CLRF FSR1L, ACCESS
0594  52E5     MOVF POSTDEC1, F, ACCESS
0596  6EE1     MOVWF FSR1L, ACCESS
0598  5014     MOVF __tmp_0, W, ACCESS
059A  D0E8     BRA __pa_3
151:           
152:           void nrf_init(void) {
059C  D970     RCALL __pa_24
153:               char status;
154:               //Configure SPI for NRF
155:               // TODO set this up to work well with multiple devices on this SPI buffer
156:               SPI_STATUS = 0b00000000;	            //SPI, clock on idle to active clk trans
059E  6AC7     CLRF SSPSTAT, ACCESS
157:               SPI_CLK_EDGE = 1; 	                    //clock on active to idle clk trans
05A0  8CC7     BSF SSPSTAT, 6, ACCESS
158:               SPI_CONFIG_1 = SPI_CONFIG_1_VALUE;	    //SPI nrf_SETup. clk at 1/16; idle low.
05A2  0E22     MOVLW 0x22
05A4  6EC6     MOVWF SSPCON1, ACCESS
159:               SPI_CLK_POL = 0;	                    //clock polarity, idle low
05A6  98C6     BCF SSPCON1, 4, ACCESS
160:               SPI_ENABLE = nrf_SET;	                //enable SPI module
05A8  8AC6     BSF SSPCON1, 5, ACCESS
161:               CE = nrf_SET;                           //default to Standby II, nrf_CLEAR to default to Standby I (which is low power mode; no TX/RX functions)
05AA  8281     BSF PORTB, 1, ACCESS
162:               CSN = nrf_SET;	
05AC  8081     BSF PORTB, 0, ACCESS
163:           
164:           
165:               CE = nrf_CLEAR;
05AE  9281     BCF PORTB, 1, ACCESS
166:           
167:               nrf_SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);    // Writes TX_Address to nRF24L01
05B0  D8FC     RCALL __pa_7
05B2  0E30     MOVLW 0x30
05B4  D8CF     RCALL __pa_1
168:               nrf_SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH); // Use the same address on the RX device as the TX device
05B6  D8F9     RCALL __pa_7
05B8  0E2A     MOVLW 0x2A
05BA  D8CC     RCALL __pa_1
169:           
170:               nrf_SPI_RW_Reg(ACTIVATE,0x73);					//activate feature register
05BC  0E73     MOVLW 0x73
05BE  6EE6     MOVWF POSTINC1, ACCESS
05C0  0E50     MOVLW 0x50
05C2  D8C3     RCALL __pa_0
171:               nrf_SPI_RW_Reg(WRITE_REG + FEATURE, 0x06);	        	//nrf_SET features for DPL
05C4  0E06     MOVLW 0x6
05C6  6EE6     MOVWF POSTINC1, ACCESS
05C8  0E3D     MOVLW 0x3D
05CA  D8BF     RCALL __pa_0
172:               nrf_SPI_RW_Reg(WRITE_REG + DYNPD,     0b111111);		//enable DPL on all pipes
05CC  0E3F     MOVLW 0x3F
05CE  6EE6     MOVWF POSTINC1, ACCESS
05D0  0E3C     MOVLW 0x3C
05D2  D8BB     RCALL __pa_0
173:               nrf_SPI_RW_Reg(WRITE_REG + EN_AA,     0b111111);            // Enable Auto.Ack:(all pipes)
05D4  0E3F     MOVLW 0x3F
05D6  6EE6     MOVWF POSTINC1, ACCESS
05D8  0E21     MOVLW 0x21
05DA  D8B7     RCALL __pa_0
174:               nrf_SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0b0001);              // Enable Pipe0
05DC  0E01     MOVLW 0x1
05DE  6EE6     MOVWF POSTINC1, ACCESS
05E0  0E22     MOVLW 0x22
05E2  D8B3     RCALL __pa_0
175:               nrf_SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x12); // 500us + 86us, 2 retrans...
05E4  0E12     MOVLW 0x12
05E6  6EE6     MOVWF POSTINC1, ACCESS
05E8  0E24     MOVLW 0x24
05EA  D8AF     RCALL __pa_0
176:               nrf_SPI_RW_Reg(WRITE_REG + RF_CH, 40);        // Select RF channel 40
05EC  0E28     MOVLW 0x28
05EE  6EE6     MOVWF POSTINC1, ACCESS
05F0  0E25     MOVLW 0x25
05F2  D8AB     RCALL __pa_0
177:               nrf_SPI_RW_Reg(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH); // Select same RX payload width as TX Payload width
05F4  0E20     MOVLW 0x20
05F6  6EE6     MOVWF POSTINC1, ACCESS
05F8  0E31     MOVLW 0x31
05FA  D8A7     RCALL __pa_0
178:               nrf_SPI_RW_Reg(WRITE_REG + RX_PW_P1, TX_PLOAD_WIDTH); // Select same RX payload width as TX Payload width
05FC  0E20     MOVLW 0x20
05FE  6EE6     MOVWF POSTINC1, ACCESS
0600  0E32     MOVLW 0x32
0602  D8A3     RCALL __pa_0
179:               nrf_SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);   // TX_PWR:0dBm, Datarate:1Mbps, LNA:HCURR
0604  0E07     MOVLW 0x7
0606  6EE6     MOVWF POSTINC1, ACCESS
0608  0E26     MOVLW 0x26
060A  D89F     RCALL __pa_0
180:           
181:               Delay10TCYx(3);
060C  D8B3     RCALL __pa_4
182:           
183:               nrf_SPI_RW_Reg(FLUSH_RX,0);
060E  6AE6     CLRF POSTINC1, ACCESS
0610  0EE2     MOVLW 0xE2
0612  D89B     RCALL __pa_0
184:               nrf_SPI_RW_Reg(FLUSH_TX,0);
0614  D930     RCALL __pa_23
185:           
186:               status=nrf_SPI_Read(STATUS);
0616  50D8     MOVF STATUS, W, ACCESS
0618  D927     RCALL __pa_21
061A  D8F5     RCALL __pa_13
187:               nrf_SPI_RW_Reg(WRITE_REG + STATUS, status);
061C  0E20     MOVLW 0x20
061E  24D8     ADDWF STATUS, W, ACCESS
0620  D894     RCALL __pa_0
188:           
189:               nrf_SPI_RW_Reg(WRITE_REG + SETUP_AW, 0x3);
0622  0E03     MOVLW 0x3
0624  6EE6     MOVWF POSTINC1, ACCESS
0626  0E23     MOVLW 0x23
0628  D890     RCALL __pa_0
190:           
191:               CE = nrf_SET;
062A  8281     BSF PORTB, 1, ACCESS
192:           }
062C  52E5     MOVF POSTDEC1, F, ACCESS
062E  D09E     BRA __pa_3
193:           
194:           //Wait for 5ms after calling this before calling a send/receive
195:           void nrf_rxmode(void) {
196:               CE = nrf_CLEAR;
0630  9281     BCF PORTB, 1, ACCESS
197:           
198:               nrf_SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);     // Set PWR_UP bit, enable CRC(2 unsigned chars) & Prim:RX. RX_DR enabled..
0632  0E0F     MOVLW 0xF
0634  D0FF     BRA __pa_16
199:           
200:               CE = nrf_SET;
201:           }
202:           
203:           //Wait for 5ms after calling this before calling a send/receive
204:           void nrf_txmode(void) {
205:               CE = nrf_CLEAR;
0636  9281     BCF PORTB, 1, ACCESS
206:           
207:               nrf_SPI_RW_Reg(WRITE_REG + CONFIG, 0x0E);     // Set PWR_UP bit, enable CRC(2 unsigned chars) & Prim:TX. MAX_RT & TX_DS enabled..
0638  0E0E     MOVLW 0xE
063A  D0FC     BRA __pa_16
208:           
209:               CE = nrf_SET;
210:           }
211:           
212:           void nrf_powerdown(void) {
213:               CE = nrf_CLEAR;
063C  9281     BCF PORTB, 1, ACCESS
214:           
215:               nrf_SPI_RW_Reg(WRITE_REG + CONFIG, 0x0C);     // Clear PWR_UP bit
063E  0E0C     MOVLW 0xC
0640  D0F9     BRA __pa_16
0834  6EE6     MOVWF POSTINC1, ACCESS
0836  0E20     MOVLW 0x20
0838  DF88     RCALL __pa_0
216:           
217:               CE = nrf_SET;
083A  8281     BSF PORTB, 1, ACCESS
218:           }
083C  0012     RETURN 0
219:           
220:           void nrf_setTxAddr(char addr) {
0642  D88F     RCALL __pa_2
221:               CE = nrf_CLEAR;
0644  9281     BCF PORTB, 1, ACCESS
222:               Delay10TCYx(3);
0646  D896     RCALL __pa_4
223:               TX_ADDRESS[0] = addr;
0648  0EFE     MOVLW 0xFE
064A  CFDB     MOVFF PLUSW2, TX_ADDRESS
064C  FE0A     NOP
224:               nrf_SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);
064E  D8AD     RCALL __pa_7
0650  0E30     MOVLW 0x30
0652  D102     BRA __pa_19
0858  DF7D     RCALL __pa_1
225:               Delay10TCYx(3);
085A  DF8C     RCALL __pa_4
226:               CE = nrf_SET;
085C  8281     BSF PORTB, 1, ACCESS
227:           }
085E  D786     BRA __pa_3
228:           
229:           void nrf_setRxAddr(char pipe, char addr) {
0654  D886     RCALL __pa_2
230:               CE = nrf_CLEAR;
0656  9281     BCF PORTB, 1, ACCESS
231:               Delay10TCYx(3);
0658  D88D     RCALL __pa_4
232:               TX_ADDRESS[0] = addr;
065A  0EFD     MOVLW 0xFD
065C  CFDB     MOVFF PLUSW2, TX_ADDRESS
065E  FE0A     NOP
233:               nrf_SPI_Write_Buf(WRITE_REG + RX_ADDR_P0 + pipe, TX_ADDRESS, TX_ADR_WIDTH);
0660  D8A4     RCALL __pa_7
0662  0EFE     MOVLW 0xFE
0664  50DB     MOVF PLUSW2, W, ACCESS
0666  0F2A     ADDLW 0x2A
0668  D0F7     BRA __pa_19
07AA  0E05     MOVLW 0x5
07AC  6EE6     MOVWF POSTINC1, ACCESS
07AE  0E0A     MOVLW 0xA
07B0  6EE6     MOVWF POSTINC1, ACCESS
07B2  0E0E     MOVLW 0xE
07B4  6EE6     MOVWF POSTINC1, ACCESS
07B6  0012     RETURN 0
234:               Delay10TCYx(3);
235:               CE = nrf_SET;
236:           }
237:           
238:           char nrf_enablePipe(char pipe) {
066A  D8F1     RCALL __pa_18
084E  D817     RCALL __pa_24
087E  DF71     RCALL __pa_2
0880  52E6     MOVF POSTINC1, F, ACCESS
0882  0012     RETURN 0
239:               char pipeStatus;
240:               
241:               CE = nrf_CLEAR;
0850  9281     BCF PORTB, 1, ACCESS
242:               Delay10TCYx(3);
0852  DF90     RCALL __pa_4
243:               pipeStatus = nrf_SPI_Read(EN_RXADDR);
07C8  0E02     MOVLW 0x2
07CA  D84E     RCALL __pa_21
07CC  6EDF     MOVWF INDF2, ACCESS
0854  EFE4     GOTO 0x7C8
0856  F003     NOP
244:               pipeStatus = pipeStatus | (0b1 << pipe);
066C  E004     BZ 0x676
066E  90D8     BCF STATUS, 0, ACCESS
0670  36F3     RLCF PRODL, F, ACCESS
0672  06E8     DECF WREG, F, ACCESS
0674  E1FC     BNZ 0x66E
0676  50F3     MOVF PRODL, W, ACCESS
0678  10DF     IORWF INDF2, W, ACCESS
067A  D0D4     BRA __pa_15
07CE  0E01     MOVLW 0x1
07D0  6EF3     MOVWF PRODL, ACCESS
07D2  0EFE     MOVLW 0xFE
07D4  50DB     MOVF PLUSW2, W, ACCESS
07D6  0012     RETURN 0
0824  DFF0     RCALL __pa_13
245:               nrf_SPI_RW_Reg(WRITE_REG + EN_RXADDR, pipeStatus);
0826  0E22     MOVLW 0x22
0828  DF90     RCALL __pa_0
246:               Delay10TCYx(3);
082A  DFA4     RCALL __pa_4
247:               CE = nrf_SET;
082C  8281     BSF PORTB, 1, ACCESS
248:               return pipeStatus;
082E  50DF     MOVF INDF2, W, ACCESS
249:           }
0830  52E5     MOVF POSTDEC1, F, ACCESS
0832  D79C     BRA __pa_3
250:           
251:           char nrf_disablePipe(char pipe) {
067C  D8E8     RCALL __pa_18
252:               char pipeStatus;
253:               
254:               CE = nrf_CLEAR;
255:               Delay10TCYx(3);
256:               pipeStatus = nrf_SPI_Read(EN_RXADDR);
257:               pipeStatus = pipeStatus & ~(0b1 << pipe);
067E  E004     BZ 0x688
0680  90D8     BCF STATUS, 0, ACCESS
0682  36F3     RLCF PRODL, F, ACCESS
0684  06E8     DECF WREG, F, ACCESS
0686  E1FC     BNZ 0x680
0688  50F3     MOVF PRODL, W, ACCESS
068A  1CF3     COMF PRODL, W, ACCESS
068C  14DF     ANDWF INDF2, W, ACCESS
068E  D0CA     BRA __pa_15
258:               nrf_SPI_RW_Reg(WRITE_REG + EN_RXADDR, pipeStatus);
074A  6EE6     MOVWF POSTINC1, ACCESS
074C  DFB3     RCALL nrf_SPI_RW_Reg
074E  52E5     MOVF POSTDEC1, F, ACCESS
0750  52E5     MOVF POSTDEC1, F, ACCESS
0752  0012     RETURN 0
259:               Delay10TCYx(3);
0774  0E03     MOVLW 0x3
0776  6EE6     MOVWF POSTINC1, ACCESS
0778  ECE0     CALL 0xDC0, 0
077A  F006     NOP
077C  52E5     MOVF POSTDEC1, F, ACCESS
077E  0012     RETURN 0
260:               CE = nrf_SET;
261:               return pipeStatus;
262:           }
263:           
264:           char nrf_readRegister(char loc) {
0690  D868     RCALL __pa_2
265:               return nrf_SPI_Read(loc);
0692  0EFE     MOVLW 0xFE
0694  CFDB     MOVFF PLUSW2, POSTINC1
0696  FFE6     NOP
0698  D815     RCALL nrf_SPI_Read
069A  52E5     MOVF POSTDEC1, F, ACCESS
266:           }
069C  D067     BRA __pa_3
267:           
268:           
269:           
270:           
271:           
272:           
273:           
274:           
275:           
276:           /////////////////////////////////////////////////
277:           //  Internal Functions
278:           /////////////////////////////////////////////////
279:           
280:           /**************************************************
281:            * Function: nrf_SPI_RW();
282:            * 
283:            * Description:
284:            * Writes one unsigned char to nRF24L01, and return the unsigned char read
285:            * from nRF24L01 during write, according to SPI protocol
286:            **************************************************/
287:           unsigned char nrf_SPI_RW(unsigned char data) {
069E  D861     RCALL __pa_2
288:               SPI_BUFFER = data;
06A0  0EFE     MOVLW 0xFE
06A2  50DB     MOVF PLUSW2, W, ACCESS
06A4  6EC9     MOVWF SSPBUF, ACCESS
289:               while(!SPI_BUFFER_FULL_STAT);
06A6  A0C7     BTFSS SSPSTAT, 0, ACCESS
06A8  D7FE     BRA 0x6A6
290:               data = SPI_BUFFER;
06AA  0EFE     MOVLW 0xFE
06AC  CFC9     MOVFF SSPBUF, PLUSW2
06AE  FFDB     NOP
291:               return(data);
06B0  50DB     MOVF PLUSW2, W, ACCESS
292:           }
06B2  D05C     BRA __pa_3
293:           /**************************************************/
294:           
295:           /**************************************************
296:            * Function: nrf_SPI_RW_Reg();
297:            * 
298:            * Description:
299:            * Writes value 'value' to register 'reg'
300:            * must be used along with the WRITE mask
301:           **************************************************/
302:           unsigned char nrf_SPI_RW_Reg(unsigned char reg, unsigned char value) {
06B4  D8E4     RCALL __pa_24
303:               unsigned char status;
304:           
305:               CSN = nrf_CLEAR;                   // CSN low, init SPI transaction
06B6  D864     RCALL __pa_5
306:               status = nrf_SPI_RW(reg);             // select register
06B8  6EDF     MOVWF INDF2, ACCESS
307:               nrf_SPI_RW(value);                    // ..and write value to it..
06BA  0EFD     MOVLW 0xFD
06BC  CFDB     MOVFF PLUSW2, POSTINC1
06BE  FFE6     NOP
06C0  D8D7     RCALL __pa_22
308:               CSN = nrf_SET;                    // CSN high again
06C2  D0CE     BRA __pa_20
309:           
310:               return status;                   // return nRF24L01 status unsigned char
311:           }
312:           /**************************************************/
313:           
314:           /**************************************************
315:            * Function: nrf_SPI_Read();
316:            * 
317:            * Description:
318:            * Read one unsigned char from nRF24L01 register, 'reg'
319:           **************************************************/
320:           unsigned char nrf_SPI_Read(unsigned char reg) {
06C4  D8DC     RCALL __pa_24
0762  CFD9     MOVFF FSR2L, POSTINC1
0764  FFE6     NOP
0766  CFE1     MOVFF FSR1L, FSR2L
0768  FFD9     NOP
076A  0012     RETURN 0
321:               unsigned char reg_val;
322:           
323:               CSN = nrf_CLEAR;                // CSN low, initialize SPI communication...
06C6  D85C     RCALL __pa_5
324:               nrf_SPI_RW(reg);                   // Select register to read from..
325:               reg_val = nrf_SPI_RW(0);           // ..then read register value
06C8  6AE6     CLRF POSTINC1, ACCESS
06CA  D8D2     RCALL __pa_22
06CC  6EDF     MOVWF INDF2, ACCESS
326:               CSN = nrf_SET;                  // CSN high, terminate SPI communication
06CE  D0C8     BRA __pa_20
0860  8081     BSF PORTB, 0, ACCESS
327:           
328:               return(reg_val);               // return register value
0862  50DF     MOVF INDF2, W, ACCESS
329:           }
0864  52E5     MOVF POSTDEC1, F, ACCESS
0866  D782     BRA __pa_3
330:           /**************************************************/
331:           
332:           /**************************************************
333:            * Function: nrf_SPI_Read_Buf();
334:            * 
335:            * Description:
336:            * Reads 'unsigned chars' #of unsigned chars from register 'reg'
337:            * Typically used to read RX payload, Rx/Tx address
338:           **************************************************/
339:           unsigned char nrf_SPI_Read_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes) {
06D0  D8B6     RCALL __pa_17
083E  DF91     RCALL __pa_2
0840  0E02     MOVLW 0x2
0842  26E1     ADDWF FSR1L, F, ACCESS
340:               unsigned char status,i;
341:           
342:               CSN = nrf_CLEAR;                   // Set CSN low, init SPI tranaction
0844  DF9D     RCALL __pa_5
343:               status = nrf_SPI_RW(reg);       	    // Select register to write to and read status unsigned char
0846  6EDF     MOVWF INDF2, ACCESS
344:           
345:               for(i=0;i<bytes;i++) {
06D2  D889     RCALL __pa_11
06D4  E211     BC 0x6F8
06F2  0E01     MOVLW 0x1
06F4  2ADB     INCF PLUSW2, F, ACCESS
06F6  D7ED     BRA 0x6D2
07E6  0EFB     MOVLW 0xFB
07E8  50DB     MOVF PLUSW2, W, ACCESS
07EA  6EF3     MOVWF PRODL, ACCESS
07EC  0E01     MOVLW 0x1
07EE  CFDB     MOVFF PLUSW2, PRODH
07F0  FFF4     NOP
07F2  50F3     MOVF PRODL, W, ACCESS
07F4  5CF4     SUBWF PRODH, W, ACCESS
07F6  0012     RETURN 0
0848  0E01     MOVLW 0x1
084A  6ADB     CLRF PLUSW2, ACCESS
084C  0012     RETURN 0
346:                   pBuf[i] = nrf_SPI_RW(0xFF);    // Perform nrf_SPI_RW to read unsigned char from nRF24L01
06D6  68E6     SETF POSTINC1, ACCESS
06D8  D8CB     RCALL __pa_22
06DA  6EE6     MOVWF POSTINC1, ACCESS
06DC  0E01     MOVLW 0x1
06DE  50DB     MOVF PLUSW2, W, ACCESS
06E0  6EE7     MOVWF INDF1, ACCESS
06E2  D88A     RCALL __pa_12
06E4  50E7     MOVF INDF1, W, ACCESS
06E6  26E9     ADDWF FSR0L, F, ACCESS
06E8  0E00     MOVLW 0x0
06EA  22EA     ADDWFC FSR0H, F, ACCESS
06EC  52E5     MOVF POSTDEC1, F, ACCESS
06EE  50E7     MOVF INDF1, W, ACCESS
06F0  6EEF     MOVWF INDF0, ACCESS
07F8  0EFC     MOVLW 0xFC
07FA  CFDB     MOVFF PLUSW2, FSR0L
07FC  FFE9     NOP
07FE  0EFD     MOVLW 0xFD
0800  CFDB     MOVFF PLUSW2, FSR0H
0802  FFEA     NOP
0804  0012     RETURN 0
347:               }
348:           
349:               CSN = nrf_SET;                   // Set CSN high again
06F8  8081     BSF PORTB, 0, ACCESS
350:           
351:               return(status);                  // return nRF24L01 status unsigned char
06FA  50DF     MOVF INDF2, W, ACCESS
352:           }
06FC  6E14     MOVWF __tmp_0, ACCESS
06FE  0E02     MOVLW 0x2
0700  5CE1     SUBWF FSR1L, W, ACCESS
0702  E202     BC 0x708
0704  6AE1     CLRF FSR1L, ACCESS
0706  52E5     MOVF POSTDEC1, F, ACCESS
0708  6EE1     MOVWF FSR1L, ACCESS
070A  5014     MOVF __tmp_0, W, ACCESS
070C  D02F     BRA __pa_3
353:           /**************************************************/
354:           
355:           /**************************************************
356:            * Function: nrf_SPI_Write_Buf();
357:            * 
358:            * Description:
359:            * Writes contents of buffer '*pBuf' to nRF24L01
360:            * Typically used to write TX payload, Rx/Tx address
361:           **************************************************/
362:           unsigned char nrf_SPI_Write_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes) {
070E  D897     RCALL __pa_17
363:               unsigned char status,i;
364:           
365:               CSN = nrf_CLEAR;                   // Set CSN low, init SPI tranaction
0780  9081     BCF PORTB, 0, ACCESS
366:               status = nrf_SPI_RW(reg);             // Select register to write to and read status unsigned char
0782  0EFE     MOVLW 0xFE
0784  CFDB     MOVFF PLUSW2, POSTINC1
0786  FFE6     NOP
0788  EF38     GOTO 0x870
078A  F004     NOP
0870  DF16     RCALL nrf_SPI_RW
0872  52E5     MOVF POSTDEC1, F, ACCESS
0874  0012     RETURN 0
367:               for(i=0;i<bytes; i++) {             // then write all unsigned char in buffer(*pBuf)
0710  D86A     RCALL __pa_11
0712  E210     BC 0x734
072E  0E01     MOVLW 0x1
0730  2ADB     INCF PLUSW2, F, ACCESS
0732  D7EE     BRA 0x710
368:                   nrf_SPI_RW(*pBuf);
0714  D871     RCALL __pa_12
0716  50EF     MOVF INDF0, W, ACCESS
0718  6EE6     MOVWF POSTINC1, ACCESS
071A  D8AA     RCALL __pa_22
369:                   *pBuf++;
071C  0EFC     MOVLW 0xFC
071E  CFDB     MOVFF PLUSW2, FSR0L
0720  FFE9     NOP
0722  2ADB     INCF PLUSW2, F, ACCESS
0724  0EFD     MOVLW 0xFD
0726  CFDB     MOVFF PLUSW2, FSR0H
0728  FFEA     NOP
072A  E301     BNC 0x72E
072C  2ADB     INCF PLUSW2, F, ACCESS
370:               }
371:               CSN = nrf_SET;                   // Set CSN high again
0734  8081     BSF PORTB, 0, ACCESS
372:               return(status);                  // return nRF24L01 status unsigned char
0736  50DF     MOVF INDF2, W, ACCESS
373:           }
0738  6E14     MOVWF __tmp_0, ACCESS
073A  0E02     MOVLW 0x2
073C  5CE1     SUBWF FSR1L, W, ACCESS
073E  E202     BC 0x744
0740  6AE1     CLRF FSR1L, ACCESS
0742  52E5     MOVF POSTDEC1, F, ACCESS
0744  6EE1     MOVWF FSR1L, ACCESS
0746  5014     MOVF __tmp_0, W, ACCESS
0748  D011     BRA __pa_3
076C  52E5     MOVF POSTDEC1, F, ACCESS
076E  CFE7     MOVFF INDF1, FSR2L
0770  FFD9     NOP
0772  0012     RETURN 0
374:           /**************************************************/
---  /home/julian/Hobby/Development/tinkering/julianh2_tinkering/pic18f25k80.X/multipoint.c  ------------
1:             //For the RX target board, the connection is Gray, White, Orange, Blue, and Black, Red, White, Yellow
2:             
3:             #include "p18f25k80.h"
4:             #include "constants.h"
5:             #include "config.h"
6:             #include "serlcd.h"
7:             #include "nRF2401.h"
8:             #include <timers.h>
9:             #include <math.h>
10:            #include <delays.h>
11:            
12:            #define LED_RED_TRIS      TRISAbits.TRISA0
13:            #define LED_RED           PORTAbits.RA0
14:            
15:            #define LED_GREEN_TRIS    TRISAbits.TRISA1
16:            #define LED_GREEN         PORTAbits.RA1
17:            
18:            #define LED_YELLOW_TRIS   TRISAbits.TRISA2
19:            #define LED_YELLOW        PORTAbits.RA2
20:            
21:            #define EEPROM_CS_TRIS    TRISBbits.TRISB3
22:            #define EEPROM_CS         PORTBbits.RB3
23:            
24:            #define LED_ON            0
25:            #define LED_OFF           1
26:            
27:            #define STRIP_TRIS        TRISCbits.TRISC2
28:            #define STRIP             PORTCbits.RC2
29:            
30:            #define STRIP_LENGTH 125
31:            #define DATA_SIZE 375
32:            
33:            #pragma idata large_idata
34:            char led_buffer[375] = {10,0,0,0,10,0,0,0,10,10,10,10,0,0,10,0,10,0,10,0,0,10,10,10,0,10,0,10,0,0,0,0,10,10,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
35:            #pragma idata
36:            
37:            unsigned char tx_buf[MAX_PAYLOAD];
38:            unsigned char rx_buf[MAX_PAYLOAD];
39:            char runFlag=0;
40:            int timerCount = 0;
41:            int value;
42:            
43:            void setup(void);
44:            
45:            ////                            MasterCode                                 ////
46:            void masterMain(void);
47:            void masterInterrupt(void);
48:            
49:            ////                          SlaveCode                                 ////
50:            void slaveMain(void);
51:            void slaveInterrupt(void);
52:            
53:            ////                            Shared Code                                 ////
54:            void clearStrip(char r, char g, char b);
55:            void setLED(unsigned char n, char r, char g, char b);
56:            void displayStatus(char status);
57:            void delay(void);
58:            
59:            ////                            System Code                                 ////
60:            void run(void);
61:            void main(void);
62:            void INT_AT_HIGH_VECTOR(void);
63:            void HIGH_ISR(void);
64:            
65:            ////                            LED Code                                    ////
66:            void updateLEDs(void);
67:            
68:            void setup(void) {
69:                //Misc config
70:                LED_RED_TRIS = OUTPUT;
0040  9092     BCF TRISA, 0, ACCESS
71:                LED_GREEN_TRIS = OUTPUT;
0042  9292     BCF TRISA, 1, ACCESS
72:                LED_YELLOW_TRIS = OUTPUT;
0044  9492     BCF TRISA, 2, ACCESS
73:                EEPROM_CS_TRIS = OUTPUT;
0046  9693     BCF TRISB, 3, ACCESS
74:                STRIP_TRIS = OUTPUT;
0048  9494     BCF TRISC, 2, ACCESS
75:            
76:                //oscillator setup
77:                OSCCONbits.IRCF = 0b111; //sets internal osc to 111=16mhz, 110=8mhz
004A  0E8F     MOVLW 0x8F
004C  14D3     ANDWF OSCCON, W, ACCESS
004E  0970     IORLW 0x70
0050  6ED3     MOVWF OSCCON, ACCESS
78:                OSCCONbits.SCS = 0b00;
0052  0EFC     MOVLW 0xFC
0054  14D3     ANDWF OSCCON, W, ACCESS
0056  0900     IORLW 0x0
0058  6ED3     MOVWF OSCCON, ACCESS
79:                OSCTUNEbits.PLLEN = 0b1; //1=pllx4 enabled
005A  8C9B     BSF OSCTUNE, 6, ACCESS
80:            
81:                //Enable internal pullup resistor for port B
82:                INTCON2bits.RBPU = CLEAR;
005C  9EF1     BCF INTCON2, 7, ACCESS
83:                WPUB = 0b1111;
005E  010F     MOVLB 0xF
0060  0E0F     MOVLW 0xF
0062  6F5B     MOVWF 0x5B, BANKED
84:            
85:                //This is to toggle pins from digital to analog
86:                //unimp, RD3, RD2, RD1     RD1, AN10, AN9, AN8 (in order)
87:                //ANCON0 = 0b00000000;
88:                //ANCON1 = 0b11111000;
89:                ANCON0 = 0x00;
0064  6B5D     CLRF 0x5D, BANKED
90:                ANCON1 = 0x00;
0066  6B5C     CLRF 0x5C, BANKED
91:            
92:                //NRF port configure (todo: move me)
93:                TRIS_CE = OUTPUT;
0068  9293     BCF TRISB, 1, ACCESS
94:                TRIS_CSN = OUTPUT;
006A  9093     BCF TRISB, 0, ACCESS
95:                TRIS_IRQ = INPUT;
006C  8493     BSF TRISB, 2, ACCESS
96:                TRIS_SCK = OUTPUT;
006E  9694     BCF TRISC, 3, ACCESS
97:                TRIS_MISO = INPUT;
0070  8894     BSF TRISC, 4, ACCESS
98:                TRIS_MOSI = OUTPUT;
0072  9A94     BCF TRISC, 5, ACCESS
99:            
100:               //set up timer for LEDs
101:               T2CONbits.TMR2ON = 1; //enable timer 2
0074  84CA     BSF T2CON, 2, ACCESS
102:               T2CONbits.T2CKPS = 0b00; //prescaler 0b10=1/16
0076  0EFC     MOVLW 0xFC
0078  14CA     ANDWF T2CON, W, ACCESS
007A  0900     IORLW 0x0
007C  6ECA     MOVWF T2CON, ACCESS
103:               PIE1bits.TMR2IE = 0;
007E  929D     BCF PIE1, 1, ACCESS
104:               PR2 = 20;
0080  0E14     MOVLW 0x14
0082  6ECB     MOVWF PR2, ACCESS
105:           
106:               //set up timer for interrupt
107:               T0CONbits.TMR0ON = 1; //enable timer 0
0084  8ED5     BSF T0CON, 7, ACCESS
108:               T0CONbits.T0CS = 0; //select clock (0=internal,1=t0pin)
0086  9AD5     BCF T0CON, 5, ACCESS
109:               T0CONbits.PSA = 1; //disable's prescaler (1=disable, 0=enable)
0088  86D5     BSF T0CON, 3, ACCESS
110:               T0CONbits.T08BIT = 0; //set mode (1=8bit mode, 0=16bit mode)
008A  9CD5     BCF T0CON, 6, ACCESS
111:               T0CONbits.T0SE = 1; //edge select (1=falling edge, 0=rising edge)
008C  88D5     BSF T0CON, 4, ACCESS
112:               T0CONbits.T0PS = 0b000; //configure prescaler 000=1:2
008E  0EF8     MOVLW 0xF8
0090  14D5     ANDWF T0CON, W, ACCESS
0092  0900     IORLW 0x0
0094  6ED5     MOVWF T0CON, ACCESS
113:           
114:               //Set up timer0 interrupts
115:               INTCONbits.TMR0IE = 1;
0096  8AF2     BSF INTCON, 5, ACCESS
116:               INTCONbits.TMR0IF = 0;
0098  94F2     BCF INTCON, 2, ACCESS
117:               INTCONbits.PEIE = 1;
009A  8CF2     BSF INTCON, 6, ACCESS
118:               INTCONbits.GIE = 0;
009C  9EF2     BCF INTCON, 7, ACCESS
119:           
120:           
121:               //set up USB serial port
122:               TRISCbits.TRISC6 = 1;
009E  8C94     BSF TRISC, 6, ACCESS
123:               RCSTA1bits.SPEN = 1;
00A0  8EAB     BSF RCSTA1, 7, ACCESS
124:               TXSTA1bits.TXEN = 1;
00A2  8AAC     BSF TXSTA1, 5, ACCESS
125:           
126:               TXSTA1bits.SYNC = 0;
00A4  98AC     BCF TXSTA1, 4, ACCESS
127:               BAUDCON1bits.BRG16 = 0;
00A6  96A7     BCF BAUDCON1, 3, ACCESS
128:               TXSTA1bits.BRGH = 1;
00A8  84AC     BSF TXSTA1, 2, ACCESS
129:           
130:               // 19.2kbaud = 001, 832
131:               SPBRG1 = 34;
00AA  0E22     MOVLW 0x22
00AC  6EAF     MOVWF SPBRG1, ACCESS
132:               
133:               //9.6kbaud = 000, 103
134:               //SPBRG1 = 103;
135:               RCSTA1bits.CREN = SET;
00AE  88AB     BSF RCSTA1, 4, ACCESS
136:           }
00B0  0012     RETURN 0
137:           
138:           ////////////////////////////////////////////////////////////////////////////////
139:           ////                                                                        ////
140:           ////                            Sender Code                                 ////
141:           ////                                                                        ////
142:           ////////////////////////////////////////////////////////////////////////////////
143:           void masterMain() {
144:           
145:           }
00B2  0012     RETURN 0
146:           
147:           void masterInterrupt(void) {
148:           
149:           }
00B4  0012     RETURN 0
150:           
151:           ////////////////////////////////////////////////////////////////////////////////
152:           ////                                                                        ////
153:           ////                            Receiver Code                               ////
154:           ////                                                                        ////
155:           ////////////////////////////////////////////////////////////////////////////////
156:           
157:           void processPacket(char * buf) {
00B6  D9C9     RCALL __pa_1
00B8  0E08     MOVLW 0x8
00BA  26E1     ADDWF FSR1L, F, ACCESS
158:               int loc = buf[0];
00BC  D9DC     RCALL __pa_5
00BE  CFEF     MOVFF INDF0, __tmp_0
00C0  F014     NOP
00C2  6A15     CLRF 0x15, ACCESS
00C4  BE14     BTFSC __tmp_0, 7, ACCESS
00C6  6815     SETF 0x15, ACCESS
00C8  C014     MOVFF __tmp_0, POSTINC2
00CA  FFDE     NOP
00CC  C015     MOVFF 0x15, POSTDEC2
00CE  FFDD     NOP
0476  0EFD     MOVLW 0xFD
0478  CFDB     MOVFF PLUSW2, FSR0L
047A  FFE9     NOP
047C  0EFE     MOVLW 0xFE
047E  CFDB     MOVFF PLUSW2, FSR0H
0480  FFEA     NOP
0482  0012     RETURN 0
159:               int len = buf[1];
00D0  0E01     MOVLW 0x1
00D2  6EE7     MOVWF INDF1, ACCESS
00D4  D9D0     RCALL __pa_5
00D6  50E7     MOVF INDF1, W, ACCESS
00D8  26E9     ADDWF FSR0L, F, ACCESS
00DA  0E00     MOVLW 0x0
00DC  22EA     ADDWFC FSR0H, F, ACCESS
00DE  CFEF     MOVFF INDF0, __tmp_0
00E0  F014     NOP
00E2  6A15     CLRF 0x15, ACCESS
00E4  BE14     BTFSC __tmp_0, 7, ACCESS
00E6  6815     SETF 0x15, ACCESS
00E8  0E02     MOVLW 0x2
00EA  C014     MOVFF __tmp_0, PLUSW2
00EC  FFDB     NOP
00EE  0E03     MOVLW 0x3
00F0  C015     MOVFF 0x15, PLUSW2
00F2  FFDB     NOP
160:               int i;
161:               int n;
162:           
163:               for (i = 0; i<len; i++) {
00F4  0E04     MOVLW 0x4
00F6  6ADB     CLRF PLUSW2, ACCESS
00F8  0E05     MOVLW 0x5
00FA  6ADB     CLRF PLUSW2, ACCESS
00FC  D9B4     RCALL __pa_4
00FE  CFDB     MOVFF PLUSW2, 0x16
0100  F016     NOP
0102  0E03     MOVLW 0x3
0104  CFDB     MOVFF PLUSW2, 0x17
0106  F017     NOP
0108  5015     MOVF 0x15, W, ACCESS
010A  1817     XORWF 0x17, W, ACCESS
010C  AEE8     BTFSS WREG, 7, ACCESS
010E  D002     BRA 0x114
0110  3417     RLCF 0x17, W, ACCESS
0112  D004     BRA 0x11C
0114  5016     MOVF 0x16, W, ACCESS
0116  5C14     SUBWF __tmp_0, W, ACCESS
0118  5017     MOVF 0x17, W, ACCESS
011A  5815     SUBWFB 0x15, W, ACCESS
011C  E244     BC 0x1A6
019A  0E04     MOVLW 0x4
019C  2ADB     INCF PLUSW2, F, ACCESS
019E  0E05     MOVLW 0x5
01A0  E3AD     BNC 0xFC
01A2  2ADB     INCF PLUSW2, F, ACCESS
01A4  D7AB     BRA 0xFC
0466  0E04     MOVLW 0x4
0468  CFDB     MOVFF PLUSW2, __tmp_0
046A  F014     NOP
046C  0E05     MOVLW 0x5
046E  CFDB     MOVFF PLUSW2, 0x15
0470  F015     NOP
0472  0E02     MOVLW 0x2
0474  0012     RETURN 0
164:                   n = loc*3+i;
011E  CFDE     MOVFF POSTINC2, 0x16
0120  F016     NOP
0122  CFDD     MOVFF POSTDEC2, 0x17
0124  F017     NOP
0126  0E03     MOVLW 0x3
0128  0217     MULWF 0x17, ACCESS
012A  CFF3     MOVFF PRODL, 0x17
012C  F017     NOP
012E  0216     MULWF 0x16, ACCESS
0130  50F4     MOVF PRODH, W, ACCESS
0132  2617     ADDWF 0x17, F, ACCESS
0134  0E04     MOVLW 0x4
0136  50DB     MOVF PLUSW2, W, ACCESS
0138  24F3     ADDWF PRODL, W, ACCESS
013A  6E14     MOVWF __tmp_0, ACCESS
013C  0E05     MOVLW 0x5
013E  50DB     MOVF PLUSW2, W, ACCESS
0140  2017     ADDWFC 0x17, W, ACCESS
0142  6E15     MOVWF 0x15, ACCESS
0144  0E06     MOVLW 0x6
0146  C014     MOVFF __tmp_0, PLUSW2
0148  FFDB     NOP
014A  0E07     MOVLW 0x7
014C  C015     MOVFF 0x15, PLUSW2
014E  FFDB     NOP
165:                   if (n > DATA_SIZE) continue;
0150  0E06     MOVLW 0x6
0152  CFDB     MOVFF PLUSW2, __tmp_0
0154  F014     NOP
0156  0E07     MOVLW 0x7
0158  CFDB     MOVFF PLUSW2, 0x15
015A  F015     NOP
015C  3415     RLCF 0x15, W, ACCESS
015E  E205     BC 0x16A
0160  5014     MOVF __tmp_0, W, ACCESS
0162  0877     SUBLW 0x77
0164  0E01     MOVLW 0x1
0166  5415     SUBFWB 0x15, W, ACCESS
0168  E318     BNC 0x19A
166:           
167:                   led_buffer[n] = buf[2+i];
016A  D97D     RCALL __pa_4
016C  2614     ADDWF __tmp_0, F, ACCESS
016E  0E00     MOVLW 0x0
0170  2215     ADDWFC 0x15, F, ACCESS
0172  0EFD     MOVLW 0xFD
0174  50DB     MOVF PLUSW2, W, ACCESS
0176  2414     ADDWF __tmp_0, W, ACCESS
0178  6EE9     MOVWF FSR0L, ACCESS
017A  0EFE     MOVLW 0xFE
017C  50DB     MOVF PLUSW2, W, ACCESS
017E  2015     ADDWFC 0x15, W, ACCESS
0180  6EEA     MOVWF FSR0H, ACCESS
0182  50EF     MOVF INDF0, W, ACCESS
0184  6EE6     MOVWF POSTINC1, ACCESS
0186  0E06     MOVLW 0x6
0188  CFDB     MOVFF PLUSW2, FSR0L
018A  FFE9     NOP
018C  0E07     MOVLW 0x7
018E  CFDB     MOVFF PLUSW2, FSR0H
0190  FFEA     NOP
0192  D960     RCALL __pa_2
0194  52E5     MOVF POSTDEC1, F, ACCESS
0196  50E7     MOVF INDF1, W, ACCESS
0198  6EEF     MOVWF INDF0, ACCESS
168:               }
169:           }
01A6  0E08     MOVLW 0x8
01A8  5CE1     SUBWF FSR1L, W, ACCESS
01AA  E202     BC 0x1B0
01AC  6AE1     CLRF FSR1L, ACCESS
01AE  52E5     MOVF POSTDEC1, F, ACCESS
01B0  6EE1     MOVWF FSR1L, ACCESS
01B2  D155     BRA __pa_3
170:           
171:           void slaveMain() {
01B4  D94A     RCALL __pa_1
01B6  0E04     MOVLW 0x4
01B8  26E1     ADDWF FSR1L, F, ACCESS
172:               //slave
173:               int i;
174:               char offset;
175:               char status;
176:           
177:               nrf_init();
01BA  ECCE     CALL 0x59C, 0
01BC  F002     NOP
178:               delay();
01BE  D89F     RCALL delay
179:           
180:               nrf_rxmode();
01C0  EC18     CALL 0x630, 0
01C2  F003     NOP
181:               delay();
01C4  D89C     RCALL delay
182:           
183:               while(1) {
0204  D7DF     BRA 0x1C4
184:                   LED_GREEN = LED_OFF;
01C6  8280     BSF PORTA, 1, ACCESS
185:           
186:                   if (nrf_receive(&tx_buf,&rx_buf)) {
01C8  0E80     MOVLW 0x80
01CA  6EE6     MOVWF POSTINC1, ACCESS
01CC  0E00     MOVLW 0x0
01CE  6EE6     MOVWF POSTINC1, ACCESS
01D0  0E60     MOVLW 0x60
01D2  6EE6     MOVWF POSTINC1, ACCESS
01D4  0E00     MOVLW 0x0
01D6  6EE6     MOVWF POSTINC1, ACCESS
01D8  EC92     CALL 0x524, 0
01DA  F002     NOP
01DC  52E5     MOVF POSTDEC1, F, ACCESS
01DE  52E5     MOVF POSTDEC1, F, ACCESS
01E0  52E5     MOVF POSTDEC1, F, ACCESS
01E2  52E5     MOVF POSTDEC1, F, ACCESS
01E4  0900     IORLW 0x0
01E6  E009     BZ 0x1FA
187:                       processPacket(&rx_buf);
01E8  0E80     MOVLW 0x80
01EA  6EE6     MOVWF POSTINC1, ACCESS
01EC  0E00     MOVLW 0x0
01EE  6EE6     MOVWF POSTINC1, ACCESS
01F0  DF62     RCALL processPacket
01F2  52E5     MOVF POSTDEC1, F, ACCESS
01F4  52E5     MOVF POSTDEC1, F, ACCESS
188:                       updateLEDs();
01F6  D8D9     RCALL updateLEDs
189:                       LED_GREEN = LED_ON;
01F8  9280     BCF PORTA, 1, ACCESS
190:                   }
191:                   
192:                   LED_YELLOW++;
01FA  0E80     MOVLW 0x80
01FC  6EE9     MOVWF FSR0L, ACCESS
01FE  0E0F     MOVLW 0xF
0200  6EEA     MOVWF FSR0H, ACCESS
0202  74EF     BTG INDF0, 2, ACCESS
193:                   delay();
194:               }
195:           }
196:           
197:           void slaveInterrupt() {
198:           
199:           }
0206  0012     RETURN 0
200:           
201:           ////////////////////////////////////////////////////////////////////////////////
202:           ////                                                                        ////
203:           ////                            Shared Code                                 ////
204:           ////                                                                        ////
205:           ////////////////////////////////////////////////////////////////////////////////
206:           
207:           void clearStrip(char r, char g, char b) {
0208  D920     RCALL __pa_1
020A  52E6     MOVF POSTINC1, F, ACCESS
208:               char i = 0;
020C  6ADF     CLRF INDF2, ACCESS
209:               for (i=0; i<STRIP_LENGTH; i++) {
020E  6ADF     CLRF INDF2, ACCESS
0210  CFDF     MOVFF INDF2, __tmp_0
0212  F014     NOP
0214  0E7D     MOVLW 0x7D
0216  6EE7     MOVWF INDF1, ACCESS
0218  1814     XORWF __tmp_0, W, ACCESS
021A  AEE8     BTFSS WREG, 7, ACCESS
021C  D002     BRA 0x222
021E  34E7     RLCF INDF1, W, ACCESS
0220  D002     BRA 0x226
0222  50E7     MOVF INDF1, W, ACCESS
0224  5C14     SUBWF __tmp_0, W, ACCESS
0226  E212     BC 0x24C
0248  2ADF     INCF INDF2, F, ACCESS
024A  D7E2     BRA 0x210
210:                   setLED(i,r,g,b);
0228  0EFC     MOVLW 0xFC
022A  CFDB     MOVFF PLUSW2, POSTINC1
022C  FFE6     NOP
022E  0EFD     MOVLW 0xFD
0230  CFDB     MOVFF PLUSW2, POSTINC1
0232  FFE6     NOP
0234  0EFE     MOVLW 0xFE
0236  CFDB     MOVFF PLUSW2, POSTINC1
0238  FFE6     NOP
023A  CFDF     MOVFF INDF2, POSTINC1
023C  FFE6     NOP
023E  D808     RCALL setLED
0240  52E5     MOVF POSTDEC1, F, ACCESS
0242  52E5     MOVF POSTDEC1, F, ACCESS
0244  52E5     MOVF POSTDEC1, F, ACCESS
0246  52E5     MOVF POSTDEC1, F, ACCESS
211:               }
212:           }
024C  52E5     MOVF POSTDEC1, F, ACCESS
024E  D107     BRA __pa_3
213:           
214:           void setLED(unsigned char n, char r, char g, char b) {
0250  D8FC     RCALL __pa_1
0252  0E02     MOVLW 0x2
0254  26E1     ADDWF FSR1L, F, ACCESS
215:               int offset = ((int)n)*3;
0256  0EFE     MOVLW 0xFE
0258  50DB     MOVF PLUSW2, W, ACCESS
025A  0D03     MULLW 0x3
025C  CFF3     MOVFF PRODL, POSTINC2
025E  FFDE     NOP
0260  CFF4     MOVFF PRODH, POSTDEC2
0262  FFDD     NOP
216:               led_buffer[offset] = g;
0264  CFDE     MOVFF POSTINC2, FSR0L
0266  FFE9     NOP
0268  CFDD     MOVFF POSTDEC2, FSR0H
026A  FFEA     NOP
026C  D8F3     RCALL __pa_2
026E  0EFC     MOVLW 0xFC
0270  D909     RCALL __pa_6
0484  CFDB     MOVFF PLUSW2, INDF0
0486  FFEF     NOP
217:               led_buffer[offset+1] = r;
0272  0E01     MOVLW 0x1
0274  26E9     ADDWF FSR0L, F, ACCESS
0276  0E00     MOVLW 0x0
0278  22EA     ADDWFC FSR0H, F, ACCESS
027A  D8EC     RCALL __pa_2
027C  0EFD     MOVLW 0xFD
027E  D902     RCALL __pa_6
0488  CFDE     MOVFF POSTINC2, FSR0L
048A  FFE9     NOP
048C  CFDD     MOVFF POSTDEC2, FSR0H
048E  FFEA     NOP
0490  0012     RETURN 0
218:               led_buffer[offset+2] = b;
0280  0E02     MOVLW 0x2
0282  26E9     ADDWF FSR0L, F, ACCESS
0284  0E00     MOVLW 0x0
0286  22EA     ADDWFC FSR0H, F, ACCESS
0288  D8E5     RCALL __pa_2
028A  0EFB     MOVLW 0xFB
028C  CFDB     MOVFF PLUSW2, INDF0
028E  FFEF     NOP
0454  0E00     MOVLW 0x0
0456  26E9     ADDWF FSR0L, F, ACCESS
0458  0E02     MOVLW 0x2
045A  22EA     ADDWFC FSR0H, F, ACCESS
045C  0012     RETURN 0
219:           }
0290  0E02     MOVLW 0x2
0292  5CE1     SUBWF FSR1L, W, ACCESS
0294  E202     BC 0x29A
0296  6AE1     CLRF FSR1L, ACCESS
0298  52E5     MOVF POSTDEC1, F, ACCESS
029A  6EE1     MOVWF FSR1L, ACCESS
029C  D0E0     BRA __pa_3
220:           
221:           void displayStatus(char status) {
029E  D8D5     RCALL __pa_1
044A  CFD9     MOVFF FSR2L, POSTINC1
044C  FFE6     NOP
044E  CFE1     MOVFF FSR1L, FSR2L
0450  FFD9     NOP
0452  0012     RETURN 0
222:               sendLiteralBytes("stat:");
02A0  0E61     MOVLW 0x61
02A2  6EE6     MOVWF POSTINC1, ACCESS
02A4  0E0D     MOVLW 0xD
02A6  D8CB     RCALL __pa_0
223:               sendBinPad(status);
02A8  0EFE     MOVLW 0xFE
02AA  CFDB     MOVFF PLUSW2, POSTINC1
02AC  FFE6     NOP
02AE  EC8C     CALL 0xB18, 0
02B0  F005     NOP
02B2  52E5     MOVF POSTDEC1, F, ACCESS
224:               sendLiteralBytes("\n");
02B4  0E5F     MOVLW 0x5F
02B6  6EE6     MOVWF POSTINC1, ACCESS
02B8  0E0D     MOVLW 0xD
02BA  D8C1     RCALL __pa_0
225:               
226:               if (status & 0b1000000) sendLiteralBytes("DR ");
02BC  0EFE     MOVLW 0xFE
02BE  ACDB     BTFSS PLUSW2, 6, ACCESS
02C0  D004     BRA 0x2CA
02C2  0E5B     MOVLW 0x5B
02C4  6EE6     MOVWF POSTINC1, ACCESS
02C6  0E0D     MOVLW 0xD
02C8  D8BA     RCALL __pa_0
227:               if (status & 0b100000) sendLiteralBytes("DS ");
02CA  0EFE     MOVLW 0xFE
02CC  AADB     BTFSS PLUSW2, 5, ACCESS
02CE  D004     BRA 0x2D8
02D0  0E57     MOVLW 0x57
02D2  6EE6     MOVWF POSTINC1, ACCESS
02D4  0E0D     MOVLW 0xD
02D6  D8B3     RCALL __pa_0
228:               if (status & 0b10000) sendLiteralBytes("RT ");
02D8  0EFE     MOVLW 0xFE
02DA  A8DB     BTFSS PLUSW2, 4, ACCESS
02DC  D004     BRA 0x2E6
02DE  0E53     MOVLW 0x53
02E0  6EE6     MOVWF POSTINC1, ACCESS
02E2  0E0D     MOVLW 0xD
02E4  D8AC     RCALL __pa_0
229:               if (status & 0b1) sendLiteralBytes("TXF ");
02E6  0EFE     MOVLW 0xFE
02E8  A0DB     BTFSS PLUSW2, 0, ACCESS
02EA  D004     BRA 0x2F4
02EC  0E4E     MOVLW 0x4E
02EE  6EE6     MOVWF POSTINC1, ACCESS
02F0  0E0D     MOVLW 0xD
02F2  D8A5     RCALL __pa_0
230:               sendLiteralBytes("\n");
02F4  0E5F     MOVLW 0x5F
02F6  6EE6     MOVWF POSTINC1, ACCESS
02F8  0E0D     MOVLW 0xD
02FA  D8A1     RCALL __pa_0
043E  6EE6     MOVWF POSTINC1, ACCESS
0440  EC8D     CALL 0x91A, 0
0442  F004     NOP
0444  52E5     MOVF POSTDEC1, F, ACCESS
0446  52E5     MOVF POSTDEC1, F, ACCESS
0448  0012     RETURN 0
231:           }
02FC  D0B0     BRA __pa_3
045E  52E5     MOVF POSTDEC1, F, ACCESS
0460  CFE7     MOVFF INDF1, FSR2L
0462  FFD9     NOP
0464  0012     RETURN 0
232:           
233:           void delay(void) {
234:               Delay10KTCYx(254);
02FE  0EFE     MOVLW 0xFE
0300  6EE6     MOVWF POSTINC1, ACCESS
0302  EC76     CALL 0xCEC, 0
0304  F006     NOP
0306  52E5     MOVF POSTDEC1, F, ACCESS
235:           }
0308  0012     RETURN 0
236:           
237:           ////////////////////////////////////////////////////////////////////////////////
238:           ////                                                                        ////
239:           ////                            System Code                                 ////
240:           ////                                                                        ////
241:           ////////////////////////////////////////////////////////////////////////////////
242:           
243:           void run(void) {
244:               while(1) {
030C  D7FE     BRA run
245:                   //if (MODE_SELECT == MODE_SEND) {
246:                   //    masterMain();
247:                   //} else {
248:                   slaveMain();
030A  DF54     RCALL slaveMain
249:                   //}
250:               }
251:           }
252:           
253:           void main(void) {
254:               setup();
030E  DE98     RCALL setup
255:           
256:               run();
0310  DFFC     RCALL run
257:           
258:               while(1);
0312  D7FF     BRA 0x312
259:           }
260:           
261:           #pragma code high_vector=0x08
262:           void INT_AT_HIGH_VECTOR(void) {
263:               _asm GOTO HIGH_ISR _endasm
0008  EF8A     GOTO 0x314
000A  F001     NOP
264:           }
000C  0012     RETURN 0
265:           #pragma code
266:           
267:           //====== high interrupt service routine =======================================
268:           #pragma interrupt HIGH_ISR
269:           void HIGH_ISR(void) {
0314  CFDA     MOVFF FSR2H, PREINC1
0316  FFE4     NOP
0318  CFE2     MOVFF FSR1H, FSR2H
031A  FFDA     NOP
031C  CFE9     MOVFF FSR0L, PREINC1
031E  FFE4     NOP
0320  CFEA     MOVFF FSR0H, PREINC1
0322  FFE4     NOP
0324  CFF6     MOVFF TBLPTRL, PREINC1
0326  FFE4     NOP
0328  CFF7     MOVFF TBLPTRH, PREINC1
032A  FFE4     NOP
032C  CFF5     MOVFF TABLAT, PREINC1
032E  FFE4     NOP
0330  CFF3     MOVFF PRODL, PREINC1
0332  FFE4     NOP
0334  CFF4     MOVFF PRODH, PREINC1
0336  FFE4     NOP
0338  CFFA     MOVFF PCLATH, PREINC1
033A  FFE4     NOP
033C  EE00     LFSR 0, 0x0
033E  F000     NOP
0340  0E14     MOVLW 0x14
0342  04E8     DECF WREG, W, ACCESS
0344  E303     BNC 0x34C
0346  CFEE     MOVFF POSTINC0, PREINC1
0348  FFE4     NOP
034A  D7FB     BRA 0x342
034C  EE00     LFSR 0, 0x14
034E  F014     NOP
0350  0E04     MOVLW 0x4
0352  04E8     DECF WREG, W, ACCESS
0354  E303     BNC 0x35C
0356  CFEE     MOVFF POSTINC0, PREINC1
0358  FFE4     NOP
035A  D7FB     BRA 0x352
035C  52E6     MOVF POSTINC1, F, ACCESS
270:               slaveInterrupt();
035E  DF53     RCALL slaveInterrupt
271:           
272:               INTCONbits.TMR0IF = CLEAR;
0360  94F2     BCF INTCON, 2, ACCESS
273:           }
0362  52E5     MOVF POSTDEC1, F, ACCESS
0364  EE00     LFSR 0, 0x17
0366  F017     NOP
0368  0E04     MOVLW 0x4
036A  04E8     DECF WREG, W, ACCESS
036C  E303     BNC 0x374
036E  CFE5     MOVFF POSTDEC1, POSTDEC0
0370  FFED     NOP
0372  D7FB     BRA 0x36A
0374  EE00     LFSR 0, 0x13
0376  F013     NOP
0378  0E14     MOVLW 0x14
037A  04E8     DECF WREG, W, ACCESS
037C  E303     BNC 0x384
037E  CFE5     MOVFF POSTDEC1, POSTDEC0
0380  FFED     NOP
0382  D7FB     BRA 0x37A
0384  CFE5     MOVFF POSTDEC1, PCLATH
0386  FFFA     NOP
0388  CFE5     MOVFF POSTDEC1, PRODH
038A  FFF4     NOP
038C  CFE5     MOVFF POSTDEC1, PRODL
038E  FFF3     NOP
0390  CFE5     MOVFF POSTDEC1, TABLAT
0392  FFF5     NOP
0394  CFE5     MOVFF POSTDEC1, TBLPTRH
0396  FFF7     NOP
0398  CFE5     MOVFF POSTDEC1, TBLPTRL
039A  FFF6     NOP
039C  CFE5     MOVFF POSTDEC1, FSR0H
039E  FFEA     NOP
03A0  CFE5     MOVFF POSTDEC1, FSR0L
03A2  FFE9     NOP
03A4  CFE5     MOVFF POSTDEC1, FSR2H
03A6  FFDA     NOP
03A8  0011     RETFIE 1
274:           
275:           ////////////////////////////////////////////////////////////////////////////////
276:           ////                                                                        ////
277:           ////                            LED Code                                    ////
278:           ////                                                                        ////
279:           ////////////////////////////////////////////////////////////////////////////////
280:           
281:           void updateLEDs() {
03AA  CFD9     MOVFF FSR2L, POSTINC1
03AC  FFE6     NOP
03AE  CFE1     MOVFF FSR1L, FSR2L
03B0  FFD9     NOP
03B2  52E6     MOVF POSTINC1, F, ACCESS
282:               char saveGIE = INTCONbits.GIE;
03B4  50F2     MOVF INTCON, W, ACCESS
03B6  0B80     ANDLW 0x80
03B8  E001     BZ 0x3BC
03BA  0E01     MOVLW 0x1
03BC  6EDF     MOVWF INDF2, ACCESS
283:               INTCONbits.GIE = 0;
03BE  9EF2     BCF INTCON, 7, ACCESS
284:               _asm
285:                       BSF PIR1, 1, ACCESS //Set the interrupt flag so that we pass through the initial wait loop without waiting
03C0  829E     BSF PIR1, 1, ACCESS
286:           
287:                       //load the initial memory address and populate the shifting register
288:                       LFSR 0,led_buffer //1
03C2  EE02     LFSR 0, 0x200
03C4  F000     NOP
289:                       MOVF POSTINC0, 0, ACCESS //1
03C6  50EE     MOVF POSTINC0, W, ACCESS
290:                       MOVWF RXB1D7, ACCESS //1
03C8  6E3D     MOVWF 0x3D, ACCESS
291:                   startStrip:
292:                       //CURRENT LED
293:                       MOVLW  STRIP_LENGTH//1
03CA  0E7D     MOVLW 0x7D
294:                       MOVWF RXB1D4, ACCESS //1
03CC  6E3A     MOVWF 0x3A, ACCESS
295:           
296:                       //CURRENT COLOR COMPONENT
297:                       MOVLW  3//1
03CE  0E03     MOVLW 0x3
298:                       MOVWF RXB1D5, ACCESS //1
03D0  6E3B     MOVWF 0x3B, ACCESS
299:           
300:                       //CURRENT BIT
301:                       MOVLW  8//1
03D2  0E08     MOVLW 0x8
302:                       MOVWF RXB1D6, ACCESS //1
03D4  6E3C     MOVWF 0x3C, ACCESS
303:           
304:                   timerWaitLoop2:
305:                       BTFSS PIR1, 1, ACCESS //1, 2 or 3
03D6  A29E     BTFSS PIR1, 1, ACCESS
306:                       BRA timerWaitLoop2
03D8  D7FE     BRA 0x3D6
307:           
308:                       BSF PORTC, 2, ACCESS ///////////////////////////////////////////////// SET
03DA  8482     BSF PORTC, 2, ACCESS
309:           
310:                       //clear timer overflow (timer trips again in 20 cycles)
311:                       BCF PIR1, 1, ACCESS //1
03DC  929E     BCF PIR1, 1, ACCESS
312:           
313:                       //bit shift and set carry flag
314:                       RLCF RXB1D7, 1, 0 //1
03DE  363D     RLCF 0x3D, F, ACCESS
315:                       BC transmitOne //1 or 2
03E0  E20E     BC 0x3FE
316:                       //BC transmitOne
317:                       //NOP
318:           
319:                   transmitZero:
320:                       BCF PORTC, 2, ACCESS ///////////////////////////////////////////////// CLEAR
03E2  9482     BCF PORTC, 2, ACCESS
321:           
322:                       //Decrement current bit, jump if nonzero
323:                       DECF RXB1D6, 1, ACCESS //1
03E4  063C     DECF 0x3C, F, ACCESS
324:                       BNZ timerWaitLoop2
03E6  E1F7     BNZ 0x3D6
325:           
326:                       //load a new byte into memory
327:                       MOVF POSTINC0, 0, ACCESS //1
03E8  50EE     MOVF POSTINC0, W, ACCESS
328:                       MOVWF RXB1D7, ACCESS //1
03EA  6E3D     MOVWF 0x3D, ACCESS
329:           
330:                       //CURRENT BIT
331:                       MOVLW  8//1
03EC  0E08     MOVLW 0x8
332:                       MOVWF RXB1D6, ACCESS //1
03EE  6E3C     MOVWF 0x3C, ACCESS
333:           
334:                       //Decrement component count
335:                       DECF RXB1D5, 1, ACCESS //1
03F0  063B     DECF 0x3B, F, ACCESS
336:                       BNZ timerWaitLoop2
03F2  E1F1     BNZ 0x3D6
337:           
338:                       MOVLW  3//1
03F4  0E03     MOVLW 0x3
339:                       MOVWF RXB1D5, ACCESS //1
03F6  6E3B     MOVWF 0x3B, ACCESS
340:           
341:                       //Decrement LED count
342:                       DECF RXB1D4, 1, ACCESS //1
03F8  063A     DECF 0x3A, F, ACCESS
343:                       BNZ timerWaitLoop2
03FA  E1ED     BNZ 0x3D6
344:           
345:                       BRA done
03FC  D012     BRA 0x422
346:                   transmitOne:
347:                       //we have a maximum of 5 cycles here
348:                       //count NOPs
349:                       NOP
03FE  0000     NOP
350:                       NOP
0400  0000     NOP
351:                       NOP
0402  0000     NOP
352:                       NOP
0404  0000     NOP
353:                       NOP
0406  0000     NOP
354:           
355:                       BCF PORTC, 2, ACCESS ///////////////////////////////////////////////// CLEAR
0408  9482     BCF PORTC, 2, ACCESS
356:           
357:                       //Decrement current bit, jump if nonzero
358:                       DECF RXB1D6, 1, ACCESS //1
040A  063C     DECF 0x3C, F, ACCESS
359:                       BNZ timerWaitLoop2
040C  E1E4     BNZ 0x3D6
360:           
361:                       //load a new byte into memory
362:                       MOVF POSTINC0, 0, ACCESS //1
040E  50EE     MOVF POSTINC0, W, ACCESS
363:                       MOVWF RXB1D7, ACCESS //1
0410  6E3D     MOVWF 0x3D, ACCESS
364:                       
365:                       //CURRENT BIT
366:                       MOVLW  8//1
0412  0E08     MOVLW 0x8
367:                       MOVWF RXB1D6, ACCESS //1
0414  6E3C     MOVWF 0x3C, ACCESS
368:           
369:                       //decrement component count
370:                       DECF RXB1D5, 1, ACCESS //1
0416  063B     DECF 0x3B, F, ACCESS
371:                       BNZ timerWaitLoop2
0418  E1DE     BNZ 0x3D6
372:           
373:                       MOVLW  3//1
041A  0E03     MOVLW 0x3
374:                       MOVWF RXB1D5, ACCESS //1
041C  6E3B     MOVWF 0x3B, ACCESS
375:           
376:                       //decrement LED count
377:                       DECF RXB1D4, 1, ACCESS //1
041E  063A     DECF 0x3A, F, ACCESS
378:                       BNZ timerWaitLoop2
0420  E1DA     BNZ 0x3D6
379:           
380:                   done:
381:           
382:                   //################### ASM RESET ##############
383:                   // sents a reset to the LED strip
384:                   // a reset is a low for t > 50 microseconds
385:                   asm_reset:
386:                       BCF PORTC, 2, ACCESS /////////////////////////////////////////////////////
0422  9482     BCF PORTC, 2, ACCESS
387:           
388:                       MOVLW 135 //1
0424  0E87     MOVLW 0x87
389:                   loop:
390:                       ADDLW -1 //1
0426  0FFF     ADDLW 0xFF
391:                       BNZ loop //1 if false, 2 if true
0428  E1FE     BNZ 0x426
392:               _endasm
393:               INTCONbits.GIE = saveGIE;
042A  50DF     MOVF INDF2, W, ACCESS
042C  B0E8     BTFSC WREG, 0, ACCESS
042E  8EF2     BSF INTCON, 7, ACCESS
0430  A0E8     BTFSS WREG, 0, ACCESS
0432  9EF2     BCF INTCON, 7, ACCESS
394:           }
0434  52E5     MOVF POSTDEC1, F, ACCESS
0436  52E5     MOVF POSTDEC1, F, ACCESS
0438  CFE7     MOVFF INDF1, FSR2L
043A  FFD9     NOP
043C  0012     RETURN 0
---  /MCC18/v3_39/src/traditional/stdclib/__init.c  -----------------------------------------------------
0006  0012     RETURN 0
---  /MCC18/v3_39/src/traditional/startup/c018i.c  ------------------------------------------------------
0000  EFC4     GOTO 0xD88
0002  F006     NOP
0004  0012     RETURN 0
0D88  EE1D     LFSR 1, 0xD00
0D8A  F000     NOP
0D8C  EE2D     LFSR 2, 0xD00
0D8E  F000     NOP
0D90  6AF8     CLRF TBLPTRU, ACCESS
0D92  9C01     BCF i, 6, ACCESS
0D94  EC09     CALL 0xC12, 0
0D96  F006     NOP
0D98  EC03     CALL 0x6, 0
0D9A  F000     NOP
0D9C  EC87     CALL 0x30E, 0
0D9E  F001     NOP
0DA0  D7FB     BRA 0xD98
0DA2  0012     RETURN 0
0C12  0E0E     MOVLW 0xE
0C14  6EF6     MOVWF TBLPTRL, ACCESS
0C16  0E00     MOVLW 0x0
0C18  6EF7     MOVWF TBLPTRH, ACCESS
0C1A  0E00     MOVLW 0x0
0C1C  6EF8     MOVWF TBLPTRU, ACCESS
0C1E  010E     MOVLB 0xE
0C20  0009     TBLRD*+
0C22  50F5     MOVF TABLAT, W, ACCESS
0C24  6F05     MOVWF 0x5, BANKED
0C26  0009     TBLRD*+
0C28  50F5     MOVF TABLAT, W, ACCESS
0C2A  6F06     MOVWF n, BANKED
0C2C  E103     BNZ 0xC34
0C2E  6705     TSTFSZ 0x5, BANKED
0C30  D001     BRA 0xC34
0C32  D03D     BRA 0xCAE
0C34  0009     TBLRD*+
0C36  50F5     MOVF TABLAT, W, ACCESS
0C38  6F00     MOVWF loc, BANKED
0C3A  0009     TBLRD*+
0C3C  50F5     MOVF TABLAT, W, ACCESS
0C3E  6F01     MOVWF i, BANKED
0C40  0009     TBLRD*+
0C42  50F5     MOVF TABLAT, W, ACCESS
0C44  6F02     MOVWF len, BANKED
0C46  0009     TBLRD*+
0C48  0009     TBLRD*+
0C4A  50F5     MOVF TABLAT, W, ACCESS
0C4C  6EE9     MOVWF FSR0L, ACCESS
0C4E  0009     TBLRD*+
0C50  50F5     MOVF TABLAT, W, ACCESS
0C52  6EEA     MOVWF FSR0H, ACCESS
0C54  0009     TBLRD*+
0C56  0009     TBLRD*+
0C58  0009     TBLRD*+
0C5A  50F5     MOVF TABLAT, W, ACCESS
0C5C  6F03     MOVWF status, BANKED
0C5E  0009     TBLRD*+
0C60  50F5     MOVF TABLAT, W, ACCESS
0C62  6F04     MOVWF i, BANKED
0C64  0009     TBLRD*+
0C66  0009     TBLRD*+
0C68  CFF6     MOVFF TBLPTRL, data_ptr
0C6A  FE07     NOP
0C6C  CFF7     MOVFF TBLPTRH, 0xE08
0C6E  FE08     NOP
0C70  CFF8     MOVFF TBLPTRU, 0xE09
0C72  FE09     NOP
0C74  CE00     MOVFF prom, TBLPTRL
0C76  FFF6     NOP
0C78  CE01     MOVFF 0xE01, TBLPTRH
0C7A  FFF7     NOP
0C7C  CE02     MOVFF 0xE02, TBLPTRU
0C7E  FFF8     NOP
0C80  010E     MOVLB 0xE
0C82  5303     MOVF status, F, BANKED
0C84  E102     BNZ 0xC8A
0C86  5304     MOVF i, F, BANKED
0C88  E007     BZ 0xC98
0C8A  0009     TBLRD*+
0C8C  50F5     MOVF TABLAT, W, ACCESS
0C8E  6EEE     MOVWF POSTINC0, ACCESS
0C90  0703     DECF status, F, BANKED
0C92  E2F8     BC 0xC84
0C94  0704     DECF i, F, BANKED
0C96  D7F9     BRA 0xC8A
0C98  CE07     MOVFF data_ptr, TBLPTRL
0C9A  FFF6     NOP
0C9C  CE08     MOVFF 0xE08, TBLPTRH
0C9E  FFF7     NOP
0CA0  CE09     MOVFF 0xE09, TBLPTRU
0CA2  FFF8     NOP
0CA4  010E     MOVLB 0xE
0CA6  0705     DECF 0x5, F, BANKED
0CA8  0E00     MOVLW 0x0
0CAA  5B06     SUBWFB n, F, BANKED
0CAC  D7BF     BRA 0xC2C
0CAE  0012     RETURN 0
---  /MCC18/v3_39/src/traditional/proc/p18F25K80.asm  ---------------------------------------------------
0D68  0E41     MOVLW 0x41
0D6A  6EF3     MOVWF PRODL, ACCESS
0D6C  EE00     LFSR 0, 0x0
0D6E  F000     NOP
0D70  0E0E     MOVLW 0xE
0D72  D801     RCALL zero_block
0D74  0012     RETURN 0
0D76  60EA     CPFSLT FSR0H, ACCESS
0D78  D002     BRA compare_l
0D7A  6AEE     CLRF POSTINC0, ACCESS
0D7C  D7FC     BRA zero_block
0D7E  50F3     MOVF PRODL, W, ACCESS
0D80  60E9     CPFSLT FSR0L, ACCESS
0D82  0012     RETURN 0
0D84  6AEE     CLRF POSTINC0, ACCESS
0D86  D7FC     BRA loop_l
---  /MCC18/v3_39/src/traditional/math/fxm1616u.asm  ----------------------------------------------------
0CB0  C008     MOVFF 0x8, 0x12
0CB2  F012     NOP
0CB4  5008     MOVF 0x8, W, ACCESS
0CB6  020D     MULWF 0xD, ACCESS
0CB8  CFF4     MOVFF PRODH, 0x7
0CBA  F007     NOP
0CBC  CFF3     MOVFF PRODL, n
0CBE  F006     NOP
0CC0  5009     MOVF 0x9, W, ACCESS
0CC2  020E     MULWF 0xE, ACCESS
0CC4  CFF4     MOVFF PRODH, 0x9
0CC6  F009     NOP
0CC8  CFF3     MOVFF PRODL, 0x8
0CCA  F008     NOP
0CCC  020D     MULWF 0xD, ACCESS
0CCE  50F3     MOVF PRODL, W, ACCESS
0CD0  2607     ADDWF 0x7, F, ACCESS
0CD2  50F4     MOVF PRODH, W, ACCESS
0CD4  2208     ADDWFC 0x8, F, ACCESS
0CD6  6AE8     CLRF WREG, ACCESS
0CD8  2209     ADDWFC 0x9, F, ACCESS
0CDA  5012     MOVF 0x12, W, ACCESS
0CDC  020E     MULWF 0xE, ACCESS
0CDE  50F3     MOVF PRODL, W, ACCESS
0CE0  2607     ADDWF 0x7, F, ACCESS
0CE2  50F4     MOVF PRODH, W, ACCESS
0CE4  2208     ADDWFC 0x8, F, ACCESS
0CE6  6AE8     CLRF WREG, ACCESS
0CE8  2209     ADDWFC 0x9, F, ACCESS
0CEA  0C00     RETLW 0x0
---  /MCC18/v3_39/src/traditional/math/fxd1616u.c  ------------------------------------------------------
0D1A  6A05     CLRF 0x5, ACCESS
0D1C  6A04     CLRF i, ACCESS
0D1E  0E10     MOVLW 0x10
0D20  6EE7     MOVWF INDF1, ACCESS
0D22  90D8     BCF STATUS, 0, ACCESS
0D24  3608     RLCF 0x8, F, ACCESS
0D26  3609     RLCF 0x9, F, ACCESS
0D28  3604     RLCF i, F, ACCESS
0D2A  3605     RLCF 0x5, F, ACCESS
0D2C  500D     MOVF 0xD, W, ACCESS
0D2E  5C04     SUBWF i, W, ACCESS
0D30  500E     MOVF 0xE, W, ACCESS
0D32  5805     SUBWFB 0x5, W, ACCESS
0D34  E305     BNC 0xD40
0D36  500D     MOVF 0xD, W, ACCESS
0D38  5E04     SUBWF i, F, ACCESS
0D3A  500E     MOVF 0xE, W, ACCESS
0D3C  5A05     SUBWFB 0x5, F, ACCESS
0D3E  2A08     INCF 0x8, F, ACCESS
0D40  2EE7     DECFSZ INDF1, F, ACCESS
0D42  D7F0     BRA 0xD24
0D44  0012     RETURN 0
---  /MCC18/v3_39/src/traditional/math/fxd0808u.c  ------------------------------------------------------
0DA4  6A05     CLRF 0x5, ACCESS
0DA6  0E08     MOVLW 0x8
0DA8  6EE7     MOVWF INDF1, ACCESS
0DAA  90D8     BCF STATUS, 0, ACCESS
0DAC  3609     RLCF 0x9, F, ACCESS
0DAE  3605     RLCF 0x5, F, ACCESS
0DB0  500E     MOVF 0xE, W, ACCESS
0DB2  5C05     SUBWF 0x5, W, ACCESS
0DB4  E302     BNC 0xDBA
0DB6  6E05     MOVWF 0x5, ACCESS
0DB8  2A09     INCF 0x9, F, ACCESS
0DBA  2EE7     DECFSZ INDF1, F, ACCESS
0DBC  D7F7     BRA 0xDAC
0DBE  0012     RETURN 0
---  /MCC18/v3_39/src/traditional/delays/d10tcyx.asm  ---------------------------------------------------
0DC0  0EFF     MOVLW 0xFF
0DC2  50E3     MOVF PLUSW1, W, ACCESS
0DC4  4EE8     DCFSNZ WREG, F, ACCESS
0DC6  0012     RETURN 0
0DC8  0000     NOP
0DCA  D000     BRA _D10TCYXCODE_000C
0DCC  D000     BRA _D10TCYXCODE_000E
0DCE  D000     BRA D10_1
0DD0  2EE8     DECFSZ WREG, F, ACCESS
0DD2  D7FA     BRA D10x
0DD4  0012     RETURN 0
---  /MCC18/v3_39/src/traditional/delays/d10ktcyx.asm  --------------------------------------------------
0CEC  0EFF     MOVLW 0xFF
0CEE  50E3     MOVF PLUSW1, W, ACCESS
0CF0  6E19     MOVWF DelayCounter1, ACCESS
0CF2  0EEF     MOVLW 0xEF
0CF4  D001     BRA D10K_1
0CF6  0EF3     MOVLW 0xF3
0CF8  6EE7     MOVWF INDF1, ACCESS
0CFA  2EE7     DECFSZ INDF1, F, ACCESS
0CFC  EF7D     GOTO 0xCFA
0CFE  F006     NOP
0D00  0E0C     MOVLW 0xC
0D02  6E18     MOVWF DelayCounter2, ACCESS
0D04  6AE7     CLRF INDF1, ACCESS
0D06  2EE7     DECFSZ INDF1, F, ACCESS
0D08  EF83     GOTO 0xD06
0D0A  F006     NOP
0D0C  2E18     DECFSZ DelayCounter2, F, ACCESS
0D0E  EF82     GOTO 0xD04
0D10  F006     NOP
0D12  2E19     DECFSZ DelayCounter1, F, ACCESS
0D14  EF7B     GOTO 0xCF6
0D16  F006     NOP
0D18  0012     RETURN 0
